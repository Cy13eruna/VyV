<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WAGABOND MAP GENERATOR</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: white;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background-color: white;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Carregar configura√ß√µes -->
    <script src="config.js"></script>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Array para armazenar cores dos losangos (preenchimento aleat√≥rio respeitando propor√ß√µes)
        let diamondColors = [];
        let boardWidth, boardHeight;
        let hexNodes = [];
        
        // Fun√ß√£o para obter cores das configura√ß√µes
        function getColors() {
            if (window.RHOMBILLE_CONFIG) {
                return getColorsArray();
            }
            // Fallback se config n√£o carregar
            return ['#00FF00', '#007E00', '#666666', '#00FFFF'];
        }
        
        // Fun√ß√£o para obter propor√ß√µes das configura√ß√µes
        function getProportions() {
            if (window.RHOMBILLE_CONFIG) {
                return getProportionsArray();
            }
            // Fallback se config n√£o carregar
            return [1/3, 1/6, 1/6, 1/6];
        }
        
        // Fun√ß√£o para obter tamanho do hex das configura√ß√µes
        function getHexSize() {
            if (window.RHOMBILLE_CONFIG) {
                return getEffectiveHexSize();
            }
            // Fallback se config n√£o carregar
            return 50;
        }
        
        // Fun√ß√£o para converter hex para rgba
        function hexToRgba(hex, alpha = 1) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (result) {
                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            return hex;
        }
        
        // Fun√ß√£o para desenhar n√≥dulo triangular (dois tri√¢ngulos sobrepostos)
        function drawTriangleNode(x, y, size, color, spacing) {
            ctx.save();
            ctx.fillStyle = color;
            
            // Tri√¢ngulo apontando para a direita
            const rightTriangleX = x + spacing / 2;
            ctx.beginPath();
            ctx.moveTo(rightTriangleX - size/2, y - size/2);  // Ponto superior esquerdo
            ctx.lineTo(rightTriangleX + size/2, y);           // Ponta direita
            ctx.lineTo(rightTriangleX - size/2, y + size/2);  // Ponto inferior esquerdo
            ctx.closePath();
            ctx.fill();
            
            // Tri√¢ngulo apontando para a esquerda
            const leftTriangleX = x - spacing / 2;
            ctx.beginPath();
            ctx.moveTo(leftTriangleX + size/2, y - size/2);   // Ponto superior direito
            ctx.lineTo(leftTriangleX - size/2, y);            // Ponta esquerda
            ctx.lineTo(leftTriangleX + size/2, y + size/2);   // Ponto inferior direito
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // Fun√ß√£o para desenhar losango com APENAS as pontas agudas arredondadas
        function drawRoundedDiamond(vertices, roundRadius) {
            ctx.beginPath();
            
            // vertices[0] = from (ponta aguda)
            // vertices[1] = lateral direita (obtuso)
            // vertices[2] = to (ponta aguda)  
            // vertices[3] = lateral esquerda (obtuso)
            
            // Come√ßar do primeiro v√©rtice lateral (obtuso)
            ctx.moveTo(vertices[1].x, vertices[1].y);
            
            // Ir para a primeira ponta aguda (vertices[2] = to) com arredondamento
            const toVertex = vertices[2];
            const lateral1 = vertices[1];
            const lateral2 = vertices[3];
            
            // Calcular vetores para a ponta aguda 'to'
            const toVecPrev = {
                x: lateral1.x - toVertex.x,
                y: lateral1.y - toVertex.y
            };
            const toVecNext = {
                x: lateral2.x - toVertex.x,
                y: lateral2.y - toVertex.y
            };
            
            // Normalizar
            const toLenPrev = Math.sqrt(toVecPrev.x * toVecPrev.x + toVecPrev.y * toVecPrev.y);
            const toLenNext = Math.sqrt(toVecNext.x * toVecNext.x + toVecNext.y * toVecNext.y);
            
            toVecPrev.x /= toLenPrev;
            toVecPrev.y /= toLenPrev;
            toVecNext.x /= toLenNext;
            toVecNext.y /= toLenNext;
            
            // Pontos de controle para a ponta aguda 'to'
            const toStartPoint = {
                x: toVertex.x + toVecPrev.x * roundRadius,
                y: toVertex.y + toVecPrev.y * roundRadius
            };
            const toEndPoint = {
                x: toVertex.x + toVecNext.x * roundRadius,
                y: toVertex.y + toVecNext.y * roundRadius
            };
            
            // Desenhar linha at√© o in√≠cio do arco da ponta 'to'
            ctx.lineTo(toStartPoint.x, toStartPoint.y);
            // Arco arredondado na ponta 'to'
            ctx.arcTo(toVertex.x, toVertex.y, toEndPoint.x, toEndPoint.y, roundRadius);
            
            // Ir para o v√©rtice lateral (obtuso) - sem arredondamento
            ctx.lineTo(vertices[3].x, vertices[3].y);
            
            // Ir para a segunda ponta aguda (vertices[0] = from) com arredondamento
            const fromVertex = vertices[0];
            const lateral3 = vertices[3];
            const lateral4 = vertices[1];
            
            // Calcular vetores para a ponta aguda 'from'
            const fromVecPrev = {
                x: lateral3.x - fromVertex.x,
                y: lateral3.y - fromVertex.y
            };
            const fromVecNext = {
                x: lateral4.x - fromVertex.x,
                y: lateral4.y - fromVertex.y
            };
            
            // Normalizar
            const fromLenPrev = Math.sqrt(fromVecPrev.x * fromVecPrev.x + fromVecPrev.y * fromVecPrev.y);
            const fromLenNext = Math.sqrt(fromVecNext.x * fromVecNext.x + fromVecNext.y * fromVecNext.y);
            
            fromVecPrev.x /= fromLenPrev;
            fromVecPrev.y /= fromLenPrev;
            fromVecNext.x /= fromLenNext;
            fromVecNext.y /= fromLenNext;
            
            // Pontos de controle para a ponta aguda 'from'
            const fromStartPoint = {
                x: fromVertex.x + fromVecPrev.x * roundRadius,
                y: fromVertex.y + fromVecPrev.y * roundRadius
            };
            const fromEndPoint = {
                x: fromVertex.x + fromVecNext.x * roundRadius,
                y: fromVertex.y + fromVecNext.y * roundRadius
            };
            
            // Desenhar linha at√© o in√≠cio do arco da ponta 'from'
            ctx.lineTo(fromStartPoint.x, fromStartPoint.y);
            // Arco arredondado na ponta 'from'
            ctx.arcTo(fromVertex.x, fromVertex.y, fromEndPoint.x, fromEndPoint.y, roundRadius);
            
            ctx.closePath();
        }
        
        // Ajustar canvas para tela cheia
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Aplicar cor de fundo das configura√ß√µes
            if (window.RHOMBILLE_CONFIG) {
                document.body.style.backgroundColor = RHOMBILLE_CONFIG.visual.backgroundColor;
                canvas.style.backgroundColor = RHOMBILLE_CONFIG.visual.backgroundColor;
            }
            
            generateHexGrid();
            generateRandomColorDistribution();
            drawRhombilleTiling();
        }
        
        // Gerar distribui√ß√£o aleat√≥ria de cores respeitando as propor√ß√µes
        function generateRandomColorDistribution() {
            diamondColors = [];
            
            // Contar total de losangos
            let totalDiamonds = 0;
            for (let i = 0; i < hexNodes.length; i++) {
                const neighbors = getHexNeighbors(i);
                for (const neighborIdx of neighbors) {
                    if (neighborIdx > i && neighborIdx < hexNodes.length) {
                        totalDiamonds++;
                    }
                }
            }
            
            // Criar array com as cores nas propor√ß√µes configuradas
            const colorPool = [];
            const proportions = getProportions();
            
            for (let colorIndex = 0; colorIndex < 4; colorIndex++) {
                const count = Math.round(totalDiamonds * proportions[colorIndex]);
                for (let i = 0; i < count; i++) {
                    colorPool.push(colorIndex);
                }
            }
            
            // Preencher o restante com a cor principal se necess√°rio
            while (colorPool.length < totalDiamonds) {
                colorPool.push(0);
            }
            
            // Embaralhar o array para distribui√ß√£o aleat√≥ria
            for (let i = colorPool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [colorPool[i], colorPool[j]] = [colorPool[j], colorPool[i]];
            }
            
            // Atribuir cores aos losangos
            let colorIndex = 0;
            for (let i = 0; i < hexNodes.length; i++) {
                const neighbors = getHexNeighbors(i);
                for (const neighborIdx of neighbors) {
                    if (neighborIdx > i && neighborIdx < hexNodes.length) {
                        const key = `${i}-${neighborIdx}`;
                        diamondColors[key] = colorPool[colorIndex % colorPool.length];
                        colorIndex++;
                    }
                }
            }
        }
        
        // Implementa√ß√£o da fun√ß√£o draw_diamond_path_simple com CORRE√á√ÉO AGRESSIVA DE ESPA√áAMENTO
        function drawDiamondPathSimple(from, to, colorIndex) {
            const center = {
                x: (from.x + to.x) / 2.0,
                y: (from.y + to.y) / 2.0
            };
            
            const direction = {
                x: to.x - from.x,
                y: to.y - from.y
            };
            const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
            const normalized = {
                x: direction.x / length,
                y: direction.y / length
            };
            
            const perpendicular = {
                x: -normalized.y,
                y: normalized.x
            };
            
            const distance = Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2);
            
            // Usar configura√ß√µes para c√°lculo da largura
            let diamondWidth;
            if (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.math.useCustomFormula) {
                diamondWidth = distance * RHOMBILLE_CONFIG.math.customWidthMultiplier;
            } else {
                // CORRE√á√ÉO AGRESSIVA: Aumentar significativamente para eliminar gaps de 1px
                diamondWidth = (distance / (2.0 * Math.sqrt(3.0))) * 1.01; // Fator de corre√ß√£o 1%
            }
            
            // EXTENS√ÉO ADICIONAL DOS V√âRTICES PARA GARANTIR SOBREPOSI√á√ÉO
            const extensionFactor = 0.5; // Extens√£o de 0.5px em cada dire√ß√£o
            
            const vertices = [
                {
                    x: from.x - normalized.x * extensionFactor,
                    y: from.y - normalized.y * extensionFactor
                },  // Ponta aguda estendida
                {
                    x: center.x + perpendicular.x * diamondWidth,
                    y: center.y + perpendicular.y * diamondWidth
                },  // Lateral obtusa
                {
                    x: to.x + normalized.x * extensionFactor,
                    y: to.y + normalized.y * extensionFactor
                },    // Ponta aguda estendida
                {
                    x: center.x - perpendicular.x * diamondWidth,
                    y: center.y - perpendicular.y * diamondWidth
                }   // Lateral obtusa
            ];
            
            // Esfuma√ßamento das configura√ß√µes
            const enableBlur = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.enableBlur : true;
            const colors = getColors();
            const baseColor = colors[colorIndex];
            
            // Verificar se pontas arredondadas est√£o habilitadas
            const roundVertices = (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.visual.roundVertices) || false;
            const vertexRoundness = (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.visual.vertexRoundness) || 8;
            
            // DESABILITAR ANTIALIASING PARA EVITAR GAPS
            ctx.imageSmoothingEnabled = false;
            
            if (enableBlur) {
                // ESFUMA√áAMENTO UNIFORME
                
                // 1. Criar o path do losango (com ou sem pontas agudas arredondadas)
                if (roundVertices) {
                    drawRoundedDiamond(vertices, vertexRoundness);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
                
                // 2. Salvar estado e aplicar clipping
                ctx.save();
                ctx.clip();
                
                // 3. Configura√ß√µes de esfuma√ßamento
                const blurIntensity = (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.visual.blurIntensity) || 1;
                const gradientRadius = (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.visual.gradientRadius) || 1.5;
                
                // 4. Criar gradiente radial DENTRO do losango
                const radius = Math.max(diamondWidth, distance / 3) * gradientRadius;
                const gradient = ctx.createRadialGradient(
                    center.x, center.y, 0,
                    center.x, center.y, radius
                );
                
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.5, hexToRgba(baseColor, 1 - blurIntensity * 0.3));
                gradient.addColorStop(0.8, hexToRgba(baseColor, 1 - blurIntensity * 0.6));
                gradient.addColorStop(1, hexToRgba(baseColor, 1 - blurIntensity));
                
                // 5. Preencher com gradiente (limitado pelo clipping)
                ctx.fillStyle = gradient;
                ctx.fillRect(
                    center.x - radius, center.y - radius,
                    radius * 2, radius * 2
                );
                
                // 6. Restaurar estado (remove clipping)
                ctx.restore();
                
            } else {
                // VERS√ÉO NORMAL (sem esfuma√ßamento) com APENAS pontas agudas arredondadas
                if (roundVertices) {
                    drawRoundedDiamond(vertices, vertexRoundness);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
                
                ctx.fillStyle = baseColor;
                ctx.fill();
            }
            
            // Reabilitar antialiasing para outros elementos
            ctx.imageSmoothingEnabled = true;
            
            // Bordas opcionais das configura√ß√µes
            if (window.RHOMBILLE_CONFIG && RHOMBILLE_CONFIG.visual.showBorders) {
                if (roundVertices) {
                    drawRoundedDiamond(vertices, vertexRoundness);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
                
                ctx.strokeStyle = RHOMBILLE_CONFIG.visual.borderColor;
                ctx.lineWidth = RHOMBILLE_CONFIG.visual.borderWidth;
                ctx.stroke();
            }
        }
        
        // Gerar grade hexagonal com PRECIS√ÉO MELHORADA
        function generateHexGrid() {
            const hexSize = getHexSize();
            const extraCols = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.grid.extraColumns : 2;
            const extraRows = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.grid.extraRows : 2;
            const offsetX = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.grid.offsetX : 0;
            const offsetY = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.grid.offsetY : 0;
            
            boardWidth = Math.ceil(window.innerWidth / (hexSize * Math.sqrt(3))) + extraCols;
            boardHeight = Math.ceil(window.innerHeight / (hexSize * 1.5)) + extraRows;
            hexNodes = [];
            
            // USAR PRECIS√ÉO DUPLA PARA EVITAR ERROS DE ARREDONDAMENTO
            const sqrt3 = Math.sqrt(3.0);
            const sqrt3_half = sqrt3 / 2.0;
            const three_half = 3.0 / 2.0;
            
            for (let row = 0; row < boardHeight; row++) {
                for (let col = 0; col < boardWidth; col++) {
                    // C√ÅLCULO MAIS PRECISO DAS COORDENADAS COM ARREDONDAMENTO PARA PIXEL INTEIRO
                    const x = Math.round(hexSize * (sqrt3 * col + sqrt3_half * (row & 1)) + offsetX);
                    const y = Math.round(hexSize * (three_half * row) + offsetY);
                    hexNodes.push({ x, y, col, row, index: row * boardWidth + col });
                }
            }
        }
        
        // Obter vizinhos hexagonais
        function getHexNeighbors(nodeIdx) {
            const col = nodeIdx % boardWidth;
            const row = Math.floor(nodeIdx / boardWidth);
            const neighbors = [];
            
            let directions;
            if (row % 2 === 0) {
                directions = [[-1,-1], [0,-1], [-1,0], [1,0], [-1,1], [0,1]];
            } else {
                directions = [[0,-1], [1,-1], [-1,0], [1,0], [0,1], [1,1]];
            }
            
            for (const [dx, dy] of directions) {
                const newCol = col + dx;
                const newRow = row + dy;
                if (newCol >= 0 && newCol < boardWidth && newRow >= 0 && newRow < boardHeight) {
                    neighbors.push(newRow * boardWidth + newCol);
                }
            }
            
            return neighbors;
        }
        
        // Fun√ß√£o principal de desenho
        function drawRhombilleTiling() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fundo das configura√ß√µes
            const bgColor = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.backgroundColor : 'white';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar losangos
            for (let i = 0; i < hexNodes.length; i++) {
                const pos = hexNodes[i];
                const neighbors = getHexNeighbors(i);
                
                for (const neighborIdx of neighbors) {
                    if (neighborIdx > i && neighborIdx < hexNodes.length) {
                        const key = `${i}-${neighborIdx}`;
                        const colorIndex = diamondColors[key] || 0;
                        drawDiamondPathSimple(pos, hexNodes[neighborIdx], colorIndex);
                    }
                }
            }
            
            // Pontos nos v√©rtices circulares (configur√°vel)
            const showVertexPoints = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.showVertexPoints : false;
            if (showVertexPoints) {
                const vertexColor = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.vertexPointColor : 'white';
                const vertexRadius = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.vertexPointRadius : 6;
                
                ctx.fillStyle = vertexColor;
                for (let i = 0; i < hexNodes.length; i++) {
                    const pos = hexNodes[i];
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, vertexRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // N√≥dulos triangulares (configur√°vel)
            const showTriangleNodes = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.showTriangleNodes : true;
            if (showTriangleNodes) {
                const triangleColor = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.triangleNodeColor : '#000000';
                const triangleSize = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.triangleNodeSize : 12;
                const triangleSpacing = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.visual.triangleNodeSpacing : 3;
                
                for (let i = 0; i < hexNodes.length; i++) {
                    const pos = hexNodes[i];
                    drawTriangleNode(pos.x, pos.y, triangleSize, triangleColor, triangleSpacing);
                }
            }
        }
        
        // Inicializa√ß√£o
        window.addEventListener('load', () => {
            if (window.RHOMBILLE_CONFIG) {
                validateConfig();
                console.log('‚úÖ Rhombille Tiling carregado com sucesso!');
                console.log('üìê Esfuma√ßamento:', RHOMBILLE_CONFIG.visual.enableBlur);
                console.log('üî∫ N√≥dulos triangulares:', RHOMBILLE_CONFIG.visual.showTriangleNodes);
                console.log('üé® Cor dos tri√¢ngulos:', RHOMBILLE_CONFIG.visual.triangleNodeColor);
            } else {
                console.log('‚ö†Ô∏è Configura√ß√µes n√£o carregadas, usando fallbacks');
            }
            resizeCanvas();
        });
        
        // Redimensionar quando a janela mudar
        window.addEventListener('resize', resizeCanvas);
        
        // Clique para randomizar (configur√°vel)
        canvas.addEventListener('click', () => {
            const clickToRandomize = window.RHOMBILLE_CONFIG ? RHOMBILLE_CONFIG.interaction.clickToRandomize : false;
            if (clickToRandomize) {
                generateRandomColorDistribution();
                drawRhombilleTiling();
            }
        });
        
        // Fun√ß√µes utilit√°rias
        window.reloadConfig = function() {
            if (window.RHOMBILLE_CONFIG) {
                validateConfig();
                resizeCanvas();
            }
        };
    </script>
</body>
</html>