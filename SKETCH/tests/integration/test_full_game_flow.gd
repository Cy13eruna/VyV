## Test Full Game Flow - Teste de Integra√ß√£o do Fluxo Completo do Jogo\n## Simula uma partida completa com m√∫ltiplos jogadores, turnos e intera√ß√µes\n\nextends \"res://tests/test_framework.gd\"\n\nconst GameManagerClass = preload(\"res://scripts/game/game_manager.gd\")\nconst ResultClass = preload(\"res://scripts/core/result.gd\")\nconst PerformanceProfiler = preload(\"res://scripts/systems/performance_profiler.gd\")\nconst MemoryLeakDetector = preload(\"res://scripts/systems/memory_leak_detector.gd\")\n\n# Componentes do jogo\nvar game_manager: GameManagerClass\nvar hex_grid: MockHexGrid\nvar star_mapper: MockStarMapper\nvar parent_node: MockParentNode\nvar profiler: PerformanceProfiler\nvar memory_detector: MemoryLeakDetector\n\n# Estado do teste\nvar test_start_time: int\nvar players_count: int = 3\nvar turns_to_simulate: int = 5\nvar units_per_player: int = 3\n\n# Mock classes para simula√ß√£o completa\nclass MockHexGrid:\n\tvar dot_positions: Array = []\n\tvar cache: MockCache\n\t\n\tfunc _init():\n\t\tcache = MockCache.new()\n\t\t# Criar um mapa 7x7 para teste completo\n\t\tfor y in range(7):\n\t\t\tfor x in range(7):\n\t\t\t\tdot_positions.append(Vector2(x * 50, y * 50))\n\t\n\tfunc get_dot_positions():\n\t\treturn dot_positions\n\t\n\tfunc has_method(method_name):\n\t\treturn method_name == \"cache\"\n\nclass MockCache:\n\tvar diamond_colors: Array = []\n\tvar connections: Array = []\n\t\n\tfunc _init():\n\t\t# Gerar cores aleat√≥rias para terreno\n\t\tvar terrain_colors = [\n\t\t\tColor(0.0, 1.0, 0.0, 1.0),  # Verde - livre\n\t\t\tColor(0.0, 1.0, 1.0, 1.0),  # Azul - √°gua\n\t\t\tColor(0.4, 0.4, 0.4, 1.0),  # Cinza - montanha\n\t\t\tColor(0.2, 0.8, 0.2, 1.0)   # Verde claro - floresta\n\t\t]\n\t\t\n\t\t# Criar conex√µes e cores para um mapa 7x7\n\t\tfor i in range(200):  # Muitas conex√µes para teste robusto\n\t\t\tvar color_index = i % terrain_colors.size()\n\t\t\tdiamond_colors.append(terrain_colors[color_index])\n\t\t\t\n\t\t\t# Conex√µes adjacentes\n\t\t\tif i < 49:  # 7x7 = 49 posi√ß√µes\n\t\t\t\tvar from_star = i\n\t\t\t\tvar to_star = (i + 1) % 49\n\t\t\t\tconnections.append({\"index_a\": from_star, \"index_b\": to_star})\n\t\n\tfunc get_diamond_colors():\n\t\treturn diamond_colors\n\t\n\tfunc get_connections():\n\t\treturn connections\n\nclass MockStarMapper:\n\tvar stars_data: Dictionary = {}\n\t\n\tfunc _init():\n\t\t# Criar dados de estrelas para teste\n\t\tfor i in range(49):  # 7x7 mapa\n\t\t\tstars_data[i] = {\n\t\t\t\t\"id\": i,\n\t\t\t\t\"position\": Vector2(i % 7 * 50, i / 7 * 50),\n\t\t\t\t\"type\": \"normal\"\n\t\t\t}\n\t\n\tfunc get_star_data(star_id: int):\n\t\treturn stars_data.get(star_id, null)\n\nclass MockParentNode:\n\tvar children_nodes: Array = []\n\t\n\tfunc add_child(node):\n\t\tchildren_nodes.append(node)\n\t\n\tfunc remove_child(node):\n\t\tchildren_nodes.erase(node)\n\t\n\tfunc get_children():\n\t\treturn children_nodes\n\nfunc setup_full_game_test():\n\t\"\"\"Configura um teste completo do jogo\"\"\"\n\ttest_start_time = Time.get_ticks_msec()\n\t\n\t# Inicializar sistemas de monitoramento\n\tprofiler = PerformanceProfiler.get_instance()\n\tprofiler.start_profiling()\n\t\n\tmemory_detector = MemoryLeakDetector.get_instance()\n\tmemory_detector.start_tracking()\n\t\n\t# Criar componentes mock\n\thex_grid = MockHexGrid.new()\n\tstar_mapper = MockStarMapper.new()\n\tparent_node = MockParentNode.new()\n\t\n\t# Inicializar GameManager\n\tgame_manager = GameManagerClass.new()\n\tvar setup_result = game_manager.setup_references(hex_grid, star_mapper, parent_node)\n\tassert_true(setup_result.is_success(), \"GameManager deve ser configurado com sucesso\")\n\t\n\tprint(\"üéÆ Teste de fluxo completo configurado - Mapa 7x7, %d jogadores\" % players_count)\n\nfunc test_complete_game_initialization():\n\t\"\"\"Testa inicializa√ß√£o completa do jogo\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"game_initialization\")\n\t\n\t# Verificar componentes essenciais\n\tassert_not_null(game_manager, \"GameManager deve existir\")\n\tassert_not_null(game_manager.hex_grid_ref, \"HexGrid deve estar configurado\")\n\tassert_not_null(game_manager.shared_game_state, \"SharedGameState deve existir\")\n\t\n\t# Verificar estado inicial\n\tvar initial_units = game_manager.get_all_units()\n\tvar initial_domains = game_manager.get_all_domains()\n\t\n\tassert_equal(initial_units.size(), 0, \"Deve come√ßar sem unidades\")\n\tassert_equal(initial_domains.size(), 0, \"Deve come√ßar sem dom√≠nios\")\n\t\n\tvar init_time = profiler.end_timer(\"game_initialization\")\n\tassert_true(init_time < 100.0, \"Inicializa√ß√£o deve ser r√°pida (< 100ms): %.2f ms\" % init_time)\n\t\n\tprint(\"‚úÖ Inicializa√ß√£o completa em %.2f ms\" % init_time)\n\nfunc test_multiplayer_setup():\n\t\"\"\"Testa configura√ß√£o de m√∫ltiplos jogadores\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"multiplayer_setup\")\n\t\n\t# Configurar sistema de turnos para m√∫ltiplos jogadores\n\tvar turn_manager = game_manager.shared_game_state.turn_manager\n\tturn_manager.setup(players_count)\n\t\n\t# Verificar configura√ß√£o inicial\n\tassert_equal(turn_manager.get_current_player(), 1, \"Deve come√ßar com jogador 1\")\n\tassert_equal(turn_manager.get_current_turn(), 1, \"Deve come√ßar no turno 1\")\n\tassert_equal(turn_manager.get_total_players(), players_count, \"Deve ter %d jogadores\" % players_count)\n\t\n\tvar setup_time = profiler.end_timer(\"multiplayer_setup\")\n\tprint(\"‚úÖ Setup multiplayer (%d jogadores) em %.2f ms\" % [players_count, setup_time])\n\nfunc test_unit_creation_and_positioning():\n\t\"\"\"Testa cria√ß√£o e posicionamento de unidades para todos os jogadores\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"unit_creation_batch\")\n\t\n\tvar created_units = []\n\tvar used_positions = []\n\t\n\t# Criar unidades para cada jogador\n\tfor player_id in range(1, players_count + 1):\n\t\tfor unit_index in range(units_per_player):\n\t\t\t# Encontrar posi√ß√£o livre\n\t\t\tvar position = _find_free_position(used_positions)\n\t\t\tassert_true(position >= 0, \"Deve encontrar posi√ß√£o livre\")\n\t\t\t\n\t\t\t# Criar unidade\n\t\t\tvar unit_result = game_manager.create_unit(position)\n\t\t\tassert_true(unit_result.is_success(), \"Unidade deve ser criada com sucesso\")\n\t\t\t\n\t\t\tvar unit = unit_result.get_value()\n\t\t\tassert_not_null(unit, \"Unidade deve existir\")\n\t\t\tassert_equal(unit.get_current_star_id(), position, \"Unidade deve estar na posi√ß√£o correta\")\n\t\t\t\n\t\t\tcreated_units.append(unit)\n\t\t\tused_positions.append(position)\n\t\n\t# Verificar total de unidades criadas\n\tvar total_units = game_manager.get_all_units()\n\tvar expected_total = players_count * units_per_player\n\tassert_equal(total_units.size(), expected_total, \"Deve ter %d unidades\" % expected_total)\n\t\n\tvar creation_time = profiler.end_timer(\"unit_creation_batch\")\n\tprint(\"‚úÖ Criadas %d unidades em %.2f ms\" % [expected_total, creation_time])\n\nfunc test_turn_based_movement_simulation():\n\t\"\"\"Simula movimento baseado em turnos\"\"\"\n\tsetup_full_game_test()\n\t\n\t# Configurar jogo com unidades\n\ttest_multiplayer_setup()\n\ttest_unit_creation_and_positioning()\n\t\n\tprofiler.start_timer(\"turn_simulation\")\n\t\n\tvar turn_manager = game_manager.shared_game_state.turn_manager\n\tvar successful_moves = 0\n\tvar blocked_moves = 0\n\t\n\t# Simular turnos\n\tfor turn in range(turns_to_simulate):\n\t\tfor player in range(players_count):\n\t\t\tvar current_player = turn_manager.get_current_player()\n\t\t\t\n\t\t\t# Encontrar unidades do jogador atual\n\t\t\tvar player_units = _get_player_units(current_player)\n\t\t\t\n\t\t\t# Tentar mover uma unidade aleat√≥ria\n\t\t\tif player_units.size() > 0:\n\t\t\t\tvar unit = player_units[0]\n\t\t\t\tvar valid_moves = game_manager.get_valid_adjacent_stars(unit)\n\t\t\t\t\n\t\t\t\tif valid_moves.size() > 0:\n\t\t\t\t\tvar target = valid_moves[0]\n\t\t\t\t\tvar move_success = game_manager.move_unit_to_star(unit, target)\n\t\t\t\t\t\n\t\t\t\t\tif move_success:\n\t\t\t\t\t\tsuccessful_moves += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tblocked_moves += 1\n\t\t\t\n\t\t\t# Pr√≥ximo turno\n\t\t\tturn_manager.next_turn()\n\t\n\tvar simulation_time = profiler.end_timer(\"turn_simulation\")\n\t\n\t# Verificar resultados da simula√ß√£o\n\tassert_true(successful_moves > 0, \"Deve haver movimentos bem-sucedidos\")\n\tassert_equal(turn_manager.get_current_turn(), turns_to_simulate + 1, \"Deve estar no turno correto\")\n\t\n\tprint(\"‚úÖ Simula√ß√£o de %d turnos: %d movimentos bem-sucedidos, %d bloqueados (%.2f ms)\" % \n\t\t[turns_to_simulate, successful_moves, blocked_moves, simulation_time])\n\nfunc test_domain_expansion_simulation():\n\t\"\"\"Simula expans√£o de dom√≠nios durante o jogo\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"domain_expansion\")\n\t\n\t# Criar alguns dom√≠nios\n\tvar domain_positions = [5, 15, 25, 35]  # Posi√ß√µes espalhadas\n\tvar created_domains = []\n\t\n\tfor i in range(domain_positions.size()):\n\t\tvar position = domain_positions[i]\n\t\tvar player_id = (i % players_count) + 1\n\t\t\n\t\t# Criar dom√≠nio\n\t\tvar domain_result = game_manager.spawn_domain_with_unit(position, player_id)\n\t\tif domain_result.is_success():\n\t\t\tcreated_domains.append(domain_result.get_value())\n\t\n\t# Verificar dom√≠nios criados\n\tvar all_domains = game_manager.get_all_domains()\n\tassert_true(all_domains.size() > 0, \"Deve haver dom√≠nios criados\")\n\tassert_true(created_domains.size() > 0, \"Deve ter criado alguns dom√≠nios\")\n\t\n\tvar expansion_time = profiler.end_timer(\"domain_expansion\")\n\tprint(\"‚úÖ Expans√£o de dom√≠nios: %d criados em %.2f ms\" % [created_domains.size(), expansion_time])\n\nfunc test_performance_during_gameplay():\n\t\"\"\"Testa performance durante gameplay intenso\"\"\"\n\tsetup_full_game_test()\n\t\n\t# Executar todos os testes de gameplay\n\ttest_multiplayer_setup()\n\ttest_unit_creation_and_positioning()\n\ttest_turn_based_movement_simulation()\n\ttest_domain_expansion_simulation()\n\t\n\t# Verificar m√©tricas de performance\n\tvar fps_stats = profiler.get_fps_stats()\n\tvar memory_stats = profiler.get_memory_stats()\n\tvar frame_stats = profiler.get_frame_time_stats()\n\t\n\t# Verificar se performance est√° aceit√°vel\n\tif fps_stats.average > 0:\n\t\tassert_true(fps_stats.average >= 30, \"FPS m√©dio deve ser >= 30: %.1f\" % fps_stats.average)\n\t\n\tif memory_stats.current_mb > 0:\n\t\tassert_true(memory_stats.current_mb < 512, \"Mem√≥ria deve ser < 512MB: %.1f MB\" % memory_stats.current_mb)\n\t\n\tprint(\"‚úÖ Performance durante gameplay: FPS %.1f, Mem√≥ria %.1f MB\" % \n\t\t[fps_stats.average, memory_stats.current_mb])\n\nfunc test_memory_leak_detection():\n\t\"\"\"Testa detec√ß√£o de vazamentos de mem√≥ria\"\"\"\n\tsetup_full_game_test()\n\t\n\t# Snapshot inicial\n\tvar initial_snapshot = memory_detector.take_memory_snapshot()\n\t\n\t# Executar opera√ß√µes que podem causar vazamentos\n\tfor i in range(100):\n\t\tvar unit_result = game_manager.create_unit(i % 49)\n\t\tif unit_result.is_success():\n\t\t\tvar unit = unit_result.get_value()\n\t\t\tmemory_detector.track_object(unit, \"test_creation\")\n\t\n\t# Limpar unidades\n\tgame_manager.clear_all_units()\n\t\n\t# Snapshot final\n\tvar final_snapshot = memory_detector.take_memory_snapshot()\n\t\n\t# Verificar vazamentos\n\tvar potential_leaks = memory_detector.check_for_leaks()\n\t\n\t# Comparar snapshots\n\tvar comparison = memory_detector.compare_snapshots(initial_snapshot, final_snapshot)\n\t\n\tprint(\"‚úÖ Detec√ß√£o de vazamentos: %d potenciais vazamentos detectados\" % potential_leaks.size())\n\tprint(\"   Diferen√ßa de objetos: %+d\" % comparison.object_diff)\n\nfunc test_error_recovery_scenarios():\n\t\"\"\"Testa cen√°rios de recupera√ß√£o de erros\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"error_recovery\")\n\t\n\t# Teste 1: Criar unidade em posi√ß√£o inv√°lida\n\tvar invalid_result = game_manager.create_unit(-1)\n\tassert_true(invalid_result.is_success(), \"Deve lidar com posi√ß√£o inv√°lida graciosamente\")\n\t\n\t# Teste 2: Mover unidade para posi√ß√£o ocupada\n\tvar unit1_result = game_manager.create_unit(0)\n\tvar unit2_result = game_manager.create_unit(1)\n\t\n\tif unit1_result.is_success() and unit2_result.is_success():\n\t\tvar unit1 = unit1_result.get_value()\n\t\tvar move_to_occupied = game_manager.move_unit_to_star(unit1, 1)\n\t\tassert_false(move_to_occupied, \"N√£o deve permitir movimento para posi√ß√£o ocupada\")\n\t\n\t# Teste 3: Opera√ß√µes com objetos null\n\tvar null_moves = game_manager.get_valid_adjacent_stars(null)\n\tassert_equal(null_moves.size(), 0, \"Deve retornar array vazio para unidade null\")\n\t\n\tvar recovery_time = profiler.end_timer(\"error_recovery\")\n\tprint(\"‚úÖ Cen√°rios de recupera√ß√£o de erros testados em %.2f ms\" % recovery_time)\n\nfunc test_cleanup_and_resource_management():\n\t\"\"\"Testa limpeza e gerenciamento de recursos\"\"\"\n\tsetup_full_game_test()\n\t\n\tprofiler.start_timer(\"cleanup_test\")\n\t\n\t# Criar muitos objetos\n\tfor i in range(50):\n\t\tgame_manager.create_unit(i % 49)\n\t\n\tfor i in range(10):\n\t\tgame_manager.spawn_domain_with_unit(i * 5, (i % players_count) + 1)\n\t\n\t# Verificar objetos criados\n\tvar units_before = game_manager.get_all_units().size()\n\tvar domains_before = game_manager.get_all_domains().size()\n\t\n\tassert_true(units_before > 0, \"Deve ter unidades criadas\")\n\tassert_true(domains_before > 0, \"Deve ter dom√≠nios criados\")\n\t\n\t# Limpar tudo\n\tgame_manager.clear_all_units()\n\tgame_manager.clear_all_domains()\n\t\n\t# Verificar limpeza\n\tvar units_after = game_manager.get_all_units().size()\n\tvar domains_after = game_manager.get_all_domains().size()\n\t\n\tassert_equal(units_after, 0, \"Todas as unidades devem ser removidas\")\n\tassert_equal(domains_after, 0, \"Todos os dom√≠nios devem ser removidos\")\n\t\n\tvar cleanup_time = profiler.end_timer(\"cleanup_test\")\n\tprint(\"‚úÖ Limpeza de %d unidades e %d dom√≠nios em %.2f ms\" % \n\t\t[units_before, domains_before, cleanup_time])\n\nfunc _find_free_position(used_positions: Array) -> int:\n\t\"\"\"Encontra uma posi√ß√£o livre no mapa\"\"\"\n\tfor i in range(49):  # 7x7 mapa\n\t\tif not i in used_positions:\n\t\t\treturn i\n\treturn -1\n\nfunc _get_player_units(player_id: int) -> Array:\n\t\"\"\"Obt√©m unidades de um jogador espec√≠fico (simulado)\"\"\"\n\tvar all_units = game_manager.get_all_units()\n\t# Para este teste, assumimos que as primeiras unidades pertencem ao primeiro jogador, etc.\n\tvar units_per_player_actual = all_units.size() / players_count\n\tvar start_index = (player_id - 1) * units_per_player_actual\n\tvar end_index = min(start_index + units_per_player_actual, all_units.size())\n\t\n\tvar player_units = []\n\tfor i in range(start_index, end_index):\n\t\tif i < all_units.size():\n\t\t\tplayer_units.append(all_units[i])\n\t\n\treturn player_units\n\nfunc generate_integration_report() -> String:\n\t\"\"\"Gera relat√≥rio completo do teste de integra√ß√£o\"\"\"\n\tvar total_time = Time.get_ticks_msec() - test_start_time\n\t\n\tvar report = \"üéÆ RELAT√ìRIO DE TESTE DE INTEGRA√á√ÉO COMPLETO\\n\"\n\treport += \"=\" * 60 + \"\\n\\n\"\n\t\n\treport += \"‚è±Ô∏è TEMPO TOTAL: %.2f segundos\\n\" % (total_time / 1000.0)\n\treport += \"üë• JOGADORES: %d\\n\" % players_count\n\treport += \"üîÑ TURNOS SIMULADOS: %d\\n\" % turns_to_simulate\n\treport += \"‚öîÔ∏è UNIDADES POR JOGADOR: %d\\n\" % units_per_player\n\treport += \"\\n\"\n\t\n\t# Performance\n\tif profiler:\n\t\treport += profiler.generate_performance_report()\n\t\n\t# Memory\n\tif memory_detector:\n\t\treport += \"\\n\" + memory_detector.generate_leak_report()\n\t\n\treturn report\n\nfunc cleanup_integration_test():\n\t\"\"\"Limpa recursos do teste de integra√ß√£o\"\"\"\n\tif game_manager:\n\t\tgame_manager.clear_all_units()\n\t\tgame_manager.clear_all_domains()\n\t\n\tif profiler:\n\t\tprofiler.stop_profiling()\n\t\n\tif memory_detector:\n\t\tmemory_detector.stop_tracking()\n\nfunc run_all_tests():\n\tprint(\"üéÆ Executando Teste de Integra√ß√£o - Fluxo Completo do Jogo...\")\n\t\n\ttest_complete_game_initialization()\n\ttest_multiplayer_setup()\n\ttest_unit_creation_and_positioning()\n\ttest_turn_based_movement_simulation()\n\ttest_domain_expansion_simulation()\n\ttest_performance_during_gameplay()\n\ttest_memory_leak_detection()\n\ttest_error_recovery_scenarios()\n\ttest_cleanup_and_resource_management()\n\t\n\t# Gerar relat√≥rio final\n\tvar report = generate_integration_report()\n\tprint(\"\\n\" + report)\n\t\n\t# Cleanup\n\tcleanup_integration_test()\n\t\n\tprint(\"‚úÖ Teste de Integra√ß√£o - Fluxo Completo conclu√≠do com sucesso!\")\n"