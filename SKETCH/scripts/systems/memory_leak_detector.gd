## Memory Leak Detector - Detector Avançado de Vazamentos de Memória\n## Monitora criação/destruição de objetos e detecta vazamentos\n\nclass_name MemoryLeakDetector\nextends RefCounted\n\n# Singleton pattern\nstatic var instance: MemoryLeakDetector\n\n# Rastreamento de objetos\nvar tracked_objects: Dictionary = {}  # object_id -> object_info\nvar object_creation_stack: Dictionary = {}  # object_id -> creation_stack\nvar object_types_count: Dictionary = {}  # class_name -> count\nvar leaked_objects: Array = []\n\n# Configurações\nvar enable_tracking: bool = false\nvar track_creation_stack: bool = false\nvar max_tracked_objects: int = 10000\nvar leak_detection_threshold: int = 100  # Objetos do mesmo tipo\n\n# Estatísticas\nvar total_objects_created: int = 0\nvar total_objects_destroyed: int = 0\nvar peak_object_count: int = 0\nvar memory_snapshots: Array = []\n\n# Tipos de objetos a ignorar (muito comuns)\nvar ignored_types: Array = [\n\t\"String\",\n\t\"int\",\n\t\"float\",\n\t\"bool\",\n\t\"Array\",\n\t\"Dictionary\"\n]\n\nstatic func get_instance() -> MemoryLeakDetector:\n\tif not instance:\n\t\tinstance = MemoryLeakDetector.new()\n\treturn instance\n\nfunc _init():\n\tif not instance:\n\t\tinstance = self\n\nfunc start_tracking():\n\t\"\"\"Inicia o rastreamento de objetos\"\"\"\n\tenable_tracking = true\n\tprint(\"🔍 Memory Leak Detector iniciado\")\n\nfunc stop_tracking():\n\t\"\"\"Para o rastreamento de objetos\"\"\"\n\tenable_tracking = false\n\tprint(\"⏹️ Memory Leak Detector parado\")\n\nfunc track_object(obj: Object, creation_context: String = \"\"):\n\t\"\"\"Registra um objeto para rastreamento\"\"\"\n\tif not enable_tracking or not obj:\n\t\treturn\n\t\n\tvar class_name = obj.get_class()\n\t\n\t# Ignorar tipos comuns\n\tif class_name in ignored_types:\n\t\treturn\n\t\n\t# Verificar limite de objetos rastreados\n\tif tracked_objects.size() >= max_tracked_objects:\n\t\tprint(\"⚠️ Limite de objetos rastreados atingido: %d\" % max_tracked_objects)\n\t\treturn\n\t\n\tvar object_id = obj.get_instance_id()\n\t\n\t# Informações do objeto\n\tvar object_info = {\n\t\t\"class_name\": class_name,\n\t\t\"creation_time\": Time.get_ticks_msec(),\n\t\t\"creation_context\": creation_context,\n\t\t\"reference_count\": obj.get_reference_count() if obj.has_method(\"get_reference_count\") else -1\n\t}\n\t\n\ttracked_objects[object_id] = object_info\n\t\n\t# Rastrear stack de criação se habilitado\n\tif track_creation_stack:\n\t\tobject_creation_stack[object_id] = get_stack_trace()\n\t\n\t# Atualizar contadores\n\ttotal_objects_created += 1\n\t\n\tif not object_types_count.has(class_name):\n\t\tobject_types_count[class_name] = 0\n\tobject_types_count[class_name] += 1\n\t\n\t# Atualizar pico\n\tvar current_count = tracked_objects.size()\n\tif current_count > peak_object_count:\n\t\tpeak_object_count = current_count\n\t\n\t# Verificar possível vazamento\n\tif object_types_count[class_name] > leak_detection_threshold:\n\t\t_report_potential_leak(class_name, object_types_count[class_name])\n\nfunc untrack_object(obj: Object):\n\t\"\"\"Remove um objeto do rastreamento\"\"\"\n\tif not enable_tracking or not obj:\n\t\treturn\n\t\n\tvar object_id = obj.get_instance_id()\n\t\n\tif tracked_objects.has(object_id):\n\t\tvar object_info = tracked_objects[object_id]\n\t\tvar class_name = object_info.class_name\n\t\t\n\t\t# Remover do rastreamento\n\t\ttracked_objects.erase(object_id)\n\t\tobject_creation_stack.erase(object_id)\n\t\t\n\t\t# Atualizar contadores\n\t\ttotal_objects_destroyed += 1\n\t\tobject_types_count[class_name] -= 1\n\t\t\n\t\tif object_types_count[class_name] <= 0:\n\t\t\tobject_types_count.erase(class_name)\n\nfunc check_for_leaks() -> Array:\n\t\"\"\"Verifica vazamentos de memória e retorna lista de objetos suspeitos\"\"\"\n\tvar potential_leaks = []\n\t\n\tfor class_name in object_types_count.keys():\n\t\tvar count = object_types_count[class_name]\n\t\t\n\t\t# Verificar se há muitos objetos do mesmo tipo\n\t\tif count > leak_detection_threshold:\n\t\t\tpotential_leaks.append({\n\t\t\t\t\"class_name\": class_name,\n\t\t\t\t\"count\": count,\n\t\t\t\t\"severity\": _calculate_leak_severity(count)\n\t\t\t})\n\t\n\t# Verificar objetos antigos\n\tvar current_time = Time.get_ticks_msec()\n\tvar old_object_threshold = 60000  # 1 minuto\n\t\n\tfor object_id in tracked_objects.keys():\n\t\tvar object_info = tracked_objects[object_id]\n\t\tvar age = current_time - object_info.creation_time\n\t\t\n\t\tif age > old_object_threshold:\n\t\t\tvar existing_leak = null\n\t\t\tfor leak in potential_leaks:\n\t\t\t\tif leak.class_name == object_info.class_name:\n\t\t\t\t\texisting_leak = leak\n\t\t\t\t\tbreak\n\t\t\t\n\t\t\tif not existing_leak:\n\t\t\t\tpotential_leaks.append({\n\t\t\t\t\t\"class_name\": object_info.class_name,\n\t\t\t\t\t\"count\": 1,\n\t\t\t\t\t\"severity\": \"old_object\",\n\t\t\t\t\t\"age_ms\": age\n\t\t\t\t})\n\t\n\treturn potential_leaks\n\nfunc take_memory_snapshot() -> Dictionary:\n\t\"\"\"Tira um snapshot da memória atual\"\"\"\n\tvar snapshot = {\n\t\t\"timestamp\": Time.get_ticks_msec(),\n\t\t\"total_objects\": tracked_objects.size(),\n\t\t\"objects_by_type\": object_types_count.duplicate(),\n\t\t\"system_memory\": OS.get_static_memory_usage_by_type(),\n\t\t\"peak_objects\": peak_object_count\n\t}\n\t\n\tmemory_snapshots.append(snapshot)\n\t\n\t# Manter apenas os últimos 10 snapshots\n\tif memory_snapshots.size() > 10:\n\t\tmemory_snapshots.pop_front()\n\t\n\treturn snapshot\n\nfunc compare_snapshots(snapshot1: Dictionary, snapshot2: Dictionary) -> Dictionary:\n\t\"\"\"Compara dois snapshots de memória\"\"\"\n\tvar comparison = {\n\t\t\"time_diff\": snapshot2.timestamp - snapshot1.timestamp,\n\t\t\"object_diff\": snapshot2.total_objects - snapshot1.total_objects,\n\t\t\"type_changes\": {},\n\t\t\"new_types\": [],\n\t\t\"removed_types\": []\n\t}\n\t\n\t# Comparar tipos de objetos\n\tvar types1 = snapshot1.objects_by_type\n\tvar types2 = snapshot2.objects_by_type\n\t\n\t# Verificar mudanças em tipos existentes\n\tfor type_name in types2.keys():\n\t\tvar count2 = types2[type_name]\n\t\tvar count1 = types1.get(type_name, 0)\n\t\tvar diff = count2 - count1\n\t\t\n\t\tif diff != 0:\n\t\t\tcomparison.type_changes[type_name] = diff\n\t\t\n\t\tif count1 == 0:\n\t\t\tcomparison.new_types.append(type_name)\n\t\n\t# Verificar tipos removidos\n\tfor type_name in types1.keys():\n\t\tif not types2.has(type_name):\n\t\t\tcomparison.removed_types.append(type_name)\n\t\n\treturn comparison\n\nfunc get_object_details(class_name: String) -> Array:\n\t\"\"\"Retorna detalhes de todos os objetos de um tipo específico\"\"\"\n\tvar details = []\n\t\n\tfor object_id in tracked_objects.keys():\n\t\tvar object_info = tracked_objects[object_id]\n\t\t\n\t\tif object_info.class_name == class_name:\n\t\t\tvar detail = object_info.duplicate()\n\t\t\tdetail.object_id = object_id\n\t\t\tdetail.age_ms = Time.get_ticks_msec() - object_info.creation_time\n\t\t\t\n\t\t\tif object_creation_stack.has(object_id):\n\t\t\t\tdetail.creation_stack = object_creation_stack[object_id]\n\t\t\t\n\t\t\tdetails.append(detail)\n\t\n\treturn details\n\nfunc get_stack_trace() -> Array:\n\t\"\"\"Obtém stack trace atual (simplificado para GDScript)\"\"\"\n\t# GDScript não tem stack trace nativo, então simulamos\n\treturn [\n\t\t\"MemoryLeakDetector.track_object()\",\n\t\t\"[Caller context would be here]\"\n\t]\n\nfunc _calculate_leak_severity(count: int) -> String:\n\t\"\"\"Calcula severidade do vazamento baseado na contagem\"\"\"\n\tif count > 1000:\n\t\treturn \"critical\"\n\telif count > 500:\n\t\treturn \"high\"\n\telif count > 200:\n\t\treturn \"medium\"\n\telse:\n\t\treturn \"low\"\n\nfunc _report_potential_leak(class_name: String, count: int):\n\t\"\"\"Reporta um possível vazamento\"\"\"\n\tvar severity = _calculate_leak_severity(count)\n\tvar message = \"Possível vazamento: %s (%d objetos) - Severidade: %s\" % [class_name, count, severity]\n\t\n\tprint(\"🚨 %s\" % message)\n\t\n\t# Adicionar à lista de vazamentos\n\tvar leak_info = {\n\t\t\"class_name\": class_name,\n\t\t\"count\": count,\n\t\t\"severity\": severity,\n\t\t\"timestamp\": Time.get_ticks_msec()\n\t}\n\t\n\tleaked_objects.append(leak_info)\n\t\n\t# Manter apenas os últimos 50 vazamentos\n\tif leaked_objects.size() > 50:\n\t\tleaked_objects.pop_front()\n\nfunc generate_leak_report() -> String:\n\t\"\"\"Gera relatório completo de vazamentos\"\"\"\n\tvar report = \"🚨 RELATÓRIO DE VAZAMENTOS DE MEMÓRIA\\n\"\n\treport += \"=\" * 50 + \"\\n\\n\"\n\t\n\t# Estatísticas gerais\n\treport += \"📊 ESTATÍSTICAS GERAIS:\\n\"\n\treport += \"Objetos criados: %d\\n\" % total_objects_created\n\treport += \"Objetos destruídos: %d\\n\" % total_objects_destroyed\n\treport += \"Objetos ativos: %d\\n\" % tracked_objects.size()\n\treport += \"Pico de objetos: %d\\n\" % peak_object_count\n\treport += \"\\n\"\n\t\n\t# Vazamentos detectados\n\tvar leaks = check_for_leaks()\n\tif leaks.size() > 0:\n\t\treport += \"🚨 VAZAMENTOS DETECTADOS:\\n\"\n\t\tfor leak in leaks:\n\t\t\treport += \"  %s: %d objetos (severidade: %s)\\n\" % [leak.class_name, leak.count, leak.severity]\n\t\treport += \"\\n\"\n\telse:\n\t\treport += \"✅ Nenhum vazamento detectado\\n\\n\"\n\t\n\t# Tipos de objetos mais comuns\n\treport += \"📈 TIPOS MAIS COMUNS:\\n\"\n\tvar sorted_types = []\n\tfor type_name in object_types_count.keys():\n\t\tsorted_types.append({\"name\": type_name, \"count\": object_types_count[type_name]})\n\t\n\tsorted_types.sort_custom(func(a, b): return a.count > b.count)\n\t\n\tfor i in range(min(10, sorted_types.size())):\n\t\tvar type_data = sorted_types[i]\n\t\treport += \"  %s: %d objetos\\n\" % [type_data.name, type_data.count]\n\t\n\treport += \"\\n\"\n\t\n\t# Snapshots de memória\n\tif memory_snapshots.size() > 1:\n\t\treport += \"📸 EVOLUÇÃO DA MEMÓRIA:\\n\"\n\t\tvar latest = memory_snapshots[-1]\n\t\tvar previous = memory_snapshots[-2]\n\t\tvar comparison = compare_snapshots(previous, latest)\n\t\t\n\t\treport += \"  Diferença de objetos: %+d\\n\" % comparison.object_diff\n\t\treport += \"  Tempo decorrido: %.1f segundos\\n\" % (comparison.time_diff / 1000.0)\n\t\t\n\t\tif comparison.type_changes.size() > 0:\n\t\t\treport += \"  Mudanças por tipo:\\n\"\n\t\t\tfor type_name in comparison.type_changes.keys():\n\t\t\t\tvar change = comparison.type_changes[type_name]\n\t\t\t\treport += \"    %s: %+d\\n\" % [type_name, change]\n\t\n\treport += \"\\n\"\n\treport += \"=\" * 50 + \"\\n\"\n\treport += \"Relatório gerado em: %s\\n\" % Time.get_datetime_string_from_system()\n\t\n\treturn report\n\nfunc cleanup_leaked_objects():\n\t\"\"\"Tenta limpar objetos vazados (use com cuidado!)\"\"\"\n\tvar cleaned_count = 0\n\t\n\tfor object_id in tracked_objects.keys():\n\t\tvar obj = instance_from_id(object_id)\n\t\tif obj and obj.has_method(\"queue_free\"):\n\t\t\tobj.queue_free()\n\t\t\tcleaned_count += 1\n\t\n\tprint(\"🧹 Tentativa de limpeza: %d objetos marcados para remoção\" % cleaned_count)\n\nfunc reset_tracking():\n\t\"\"\"Reseta todo o rastreamento\"\"\"\n\ttracked_objects.clear()\n\tobject_creation_stack.clear()\n\tobject_types_count.clear()\n\tleaked_objects.clear()\n\tmemory_snapshots.clear()\n\t\n\ttotal_objects_created = 0\n\ttotal_objects_destroyed = 0\n\tpeak_object_count = 0\n\t\n\tprint(\"🔄 Rastreamento de memória resetado\")\n\nfunc cleanup():\n\t\"\"\"Limpa recursos do detector\"\"\"\n\tstop_tracking()\n\treset_tracking()\n\tinstance = null\n"