## Test Coverage Reporter - Relatório de Cobertura de Testes\n## Analisa cobertura de testes e gera relatórios detalhados\n\nclass_name TestCoverageReporter\nextends RefCounted\n\n# Singleton pattern\nstatic var instance: TestCoverageReporter\n\n# Dados de cobertura\nvar coverage_data: Dictionary = {}\nvar test_files: Array = []\nvar source_files: Array = []\nvar coverage_percentage: float = 0.0\n\n# Configurações\nvar project_path: String = \"SKETCH/scripts\"\nvar test_path: String = \"SKETCH/tests\"\n\nstatic func get_instance() -> TestCoverageReporter:\n\tif not instance:\n\t\tinstance = TestCoverageReporter.new()\n\treturn instance\n\nfunc _init():\n\tif not instance:\n\t\tinstance = self\n\nfunc analyze_test_coverage() -> Dictionary:\n\t\"\"\"Analisa cobertura de testes do projeto\"\"\"\n\tprint(\"📊 Analisando cobertura de testes...\")\n\t\n\tcoverage_data.clear()\n\t\n\t# Obter arquivos de teste e código fonte\n\ttest_files = _get_test_files()\n\tsource_files = _get_source_files()\n\t\n\t# Analisar cada arquivo de código fonte\n\tfor source_file in source_files:\n\t\tanalyze_file_coverage(source_file)\n\t\n\t# Calcular cobertura geral\n\tcalculate_overall_coverage()\n\t\n\tprint(\"✅ Análise de cobertura concluída: %.1f%% de cobertura\" % coverage_percentage)\n\treturn coverage_data\n\nfunc analyze_file_coverage(source_file: String) -> Dictionary:\n\t\"\"\"Analisa cobertura de um arquivo específico\"\"\"\n\tvar file_coverage = {\n\t\t\"file_path\": source_file,\n\t\t\"functions\": [],\n\t\t\"classes\": [],\n\t\t\"tested_functions\": [],\n\t\t\"untested_functions\": [],\n\t\t\"coverage_percentage\": 0.0,\n\t\t\"test_files\": [],\n\t\t\"has_tests\": false\n\t}\n\t\n\t# Extrair funções e classes do arquivo fonte\n\textract_code_elements(source_file, file_coverage)\n\t\n\t# Encontrar testes relacionados\n\tfind_related_tests(source_file, file_coverage)\n\t\n\t# Calcular cobertura do arquivo\n\tcalculate_file_coverage(file_coverage)\n\t\n\tcoverage_data[source_file] = file_coverage\n\treturn file_coverage\n\nfunc extract_code_elements(file_path: String, file_coverage: Dictionary):\n\t\"\"\"Extrai funções e classes de um arquivo\"\"\"\n\tvar file = FileAccess.open(file_path, FileAccess.READ)\n\tif not file:\n\t\treturn\n\t\n\tvar content = file.get_as_text()\n\tfile.close()\n\t\n\tvar lines = content.split(\"\\n\")\n\t\n\t# Padrões regex\n\tvar func_pattern = RegEx.new()\n\tfunc_pattern.compile(r\"func\\s+(\\w+)\\s*\\(\")\n\t\n\tvar class_pattern = RegEx.new()\n\tclass_pattern.compile(r\"class_name\\s+(\\w+)\")\n\t\n\t# Extrair funções\n\tfor i in range(lines.size()):\n\t\tvar line = lines[i]\n\t\t\n\t\t# Funções\n\t\tvar func_match = func_pattern.search(line)\n\t\tif func_match:\n\t\t\tvar func_name = func_match.get_string(1)\n\t\t\t# Ignorar funções privadas e especiais\n\t\t\tif not func_name.begins_with(\"_\") and func_name != \"new\":\n\t\t\t\tfile_coverage.functions.append({\n\t\t\t\t\t\"name\": func_name,\n\t\t\t\t\t\"line\": i + 1,\n\t\t\t\t\t\"tested\": false\n\t\t\t\t})\n\t\t\n\t\t# Classes\n\t\tvar class_match = class_pattern.search(line)\n\t\tif class_match:\n\t\t\tvar class_name = class_match.get_string(1)\n\t\t\tfile_coverage.classes.append({\n\t\t\t\t\"name\": class_name,\n\t\t\t\t\"line\": i + 1,\n\t\t\t\t\"tested\": false\n\t\t\t})\n\nfunc find_related_tests(source_file: String, file_coverage: Dictionary):\n\t\"\"\"Encontra testes relacionados a um arquivo fonte\"\"\"\n\tvar source_name = source_file.get_file().get_basename()\n\tvar related_tests = []\n\t\n\t# Procurar por arquivos de teste que mencionem este arquivo\n\tfor test_file in test_files:\n\t\tvar test_content = _read_file_content(test_file)\n\t\tif test_content.is_empty():\n\t\t\tcontinue\n\t\t\n\t\t# Verificar se o teste importa ou menciona o arquivo fonte\n\t\tif (test_content.contains(source_name) or \n\t\t\ttest_content.contains(source_file) or\n\t\t\ttest_file.contains(source_name.to_lower())):\n\t\t\t\n\t\t\trelated_tests.append(test_file)\n\t\t\t\n\t\t\t# Analisar quais funções são testadas\n\t\t\tanalyze_tested_functions(test_content, file_coverage)\n\t\n\tfile_coverage.test_files = related_tests\n\tfile_coverage.has_tests = related_tests.size() > 0\n\nfunc analyze_tested_functions(test_content: String, file_coverage: Dictionary):\n\t\"\"\"Analisa quais funções são testadas\"\"\"\n\tfor func_data in file_coverage.functions:\n\t\tvar func_name = func_data.name\n\t\t\n\t\t# Procurar por padrões de teste da função\n\t\tvar test_patterns = [\n\t\t\t\"test_\" + func_name.to_lower(),\n\t\t\tfunc_name + \"(\",\n\t\t\t\".\" + func_name + \"(\",\n\t\t\t\"test.*\" + func_name\n\t\t]\n\t\t\n\t\tfor pattern in test_patterns:\n\t\t\tif test_content.contains(pattern):\n\t\t\t\tfunc_data.tested = true\n\t\t\t\tbreak\n\nfunc calculate_file_coverage(file_coverage: Dictionary):\n\t\"\"\"Calcula cobertura de um arquivo\"\"\"\n\tvar total_functions = file_coverage.functions.size()\n\tvar tested_functions = 0\n\t\n\tfor func_data in file_coverage.functions:\n\t\tif func_data.tested:\n\t\t\ttested_functions += 1\n\t\t\tfile_coverage.tested_functions.append(func_data)\n\t\telse:\n\t\t\tfile_coverage.untested_functions.append(func_data)\n\t\n\tif total_functions > 0:\n\t\tfile_coverage.coverage_percentage = (float(tested_functions) / float(total_functions)) * 100.0\n\telse:\n\t\tfile_coverage.coverage_percentage = 100.0  # Arquivo sem funções públicas\n\nfunc calculate_overall_coverage():\n\t\"\"\"Calcula cobertura geral do projeto\"\"\"\n\tvar total_functions = 0\n\tvar tested_functions = 0\n\tvar files_with_tests = 0\n\tvar total_files = coverage_data.size()\n\t\n\tfor file_path in coverage_data.keys():\n\t\tvar file_coverage = coverage_data[file_path]\n\t\t\n\t\ttotal_functions += file_coverage.functions.size()\n\t\ttested_functions += file_coverage.tested_functions.size()\n\t\t\n\t\tif file_coverage.has_tests:\n\t\t\tfiles_with_tests += 1\n\t\n\tif total_functions > 0:\n\t\tcoverage_percentage = (float(tested_functions) / float(total_functions)) * 100.0\n\telse:\n\t\tcoverage_percentage = 100.0\n\t\n\t# Adicionar métricas gerais\n\tcoverage_data[\"_summary\"] = {\n\t\t\"total_files\": total_files,\n\t\t\"files_with_tests\": files_with_tests,\n\t\t\"files_without_tests\": total_files - files_with_tests,\n\t\t\"total_functions\": total_functions,\n\t\t\"tested_functions\": tested_functions,\n\t\t\"untested_functions\": total_functions - tested_functions,\n\t\t\"overall_coverage_percentage\": coverage_percentage,\n\t\t\"file_coverage_percentage\": (float(files_with_tests) / float(total_files)) * 100.0 if total_files > 0 else 100.0\n\t}\n\nfunc get_uncovered_files() -> Array:\n\t\"\"\"Retorna arquivos sem cobertura de testes\"\"\"\n\tvar uncovered = []\n\t\n\tfor file_path in coverage_data.keys():\n\t\tif file_path == \"_summary\":\n\t\t\tcontinue\n\t\t\n\t\tvar file_coverage = coverage_data[file_path]\n\t\tif not file_coverage.has_tests or file_coverage.coverage_percentage < 50.0:\n\t\t\tuncovered.append({\n\t\t\t\t\"file\": file_path,\n\t\t\t\t\"coverage\": file_coverage.coverage_percentage,\n\t\t\t\t\"untested_functions\": file_coverage.untested_functions.size()\n\t\t\t})\n\t\n\tuncovered.sort_custom(func(a, b): return a.coverage < b.coverage)\n\treturn uncovered\n\nfunc get_best_covered_files() -> Array:\n\t\"\"\"Retorna arquivos com melhor cobertura\"\"\"\n\tvar well_covered = []\n\t\n\tfor file_path in coverage_data.keys():\n\t\tif file_path == \"_summary\":\n\t\t\tcontinue\n\t\t\n\t\tvar file_coverage = coverage_data[file_path]\n\t\tif file_coverage.coverage_percentage >= 80.0:\n\t\t\twell_covered.append({\n\t\t\t\t\"file\": file_path,\n\t\t\t\t\"coverage\": file_coverage.coverage_percentage,\n\t\t\t\t\"tested_functions\": file_coverage.tested_functions.size()\n\t\t\t})\n\t\n\twell_covered.sort_custom(func(a, b): return a.coverage > b.coverage)\n\treturn well_covered\n\nfunc suggest_test_improvements() -> Array:\n\t\"\"\"Sugere melhorias para os testes\"\"\"\n\tvar suggestions = []\n\t\n\t# Arquivos sem testes\n\tvar uncovered = get_uncovered_files()\n\tfor file_data in uncovered.slice(0, 5):  # Top 5\n\t\tsuggestions.append({\n\t\t\t\"type\": \"missing_tests\",\n\t\t\t\"priority\": \"high\" if file_data.coverage == 0.0 else \"medium\",\n\t\t\t\"message\": \"Criar testes para %s (cobertura: %.1f%%)\" % [file_data.file, file_data.coverage],\n\t\t\t\"file\": file_data.file\n\t\t})\n\t\n\t# Funções específicas sem testes\n\tfor file_path in coverage_data.keys():\n\t\tif file_path == \"_summary\":\n\t\t\tcontinue\n\t\t\n\t\tvar file_coverage = coverage_data[file_path]\n\t\tfor func_data in file_coverage.untested_functions:\n\t\t\tsuggestions.append({\n\t\t\t\t\"type\": \"untested_function\",\n\t\t\t\t\"priority\": \"medium\",\n\t\t\t\t\"message\": \"Adicionar teste para função %s::%s\" % [file_path.get_file(), func_data.name],\n\t\t\t\t\"file\": file_path,\n\t\t\t\t\"function\": func_data.name,\n\t\t\t\t\"line\": func_data.line\n\t\t\t})\n\t\n\treturn suggestions\n\nfunc generate_coverage_report() -> String:\n\t\"\"\"Gera relatório completo de cobertura\"\"\"\n\tvar report = \"📊 RELATÓRIO DE COBERTURA DE TESTES\\n\"\n\treport += \"=\" * 60 + \"\\n\\n\"\n\t\n\tif not coverage_data.has(\"_summary\"):\n\t\treport += \"⚠️ Dados de cobertura não disponíveis\\n\"\n\t\treturn report\n\t\n\tvar summary = coverage_data[\"_summary\"]\n\t\n\t# Resumo geral\n\treport += \"📈 RESUMO GERAL:\\n\"\n\treport += \"Cobertura geral: %.1f%%\\n\" % summary.overall_coverage_percentage\n\treport += \"Arquivos analisados: %d\\n\" % summary.total_files\n\treport += \"Arquivos com testes: %d\\n\" % summary.files_with_tests\n\treport += \"Arquivos sem testes: %d\\n\" % summary.files_without_tests\n\treport += \"Funções analisadas: %d\\n\" % summary.total_functions\n\treport += \"Funções testadas: %d\\n\" % summary.tested_functions\n\treport += \"Funções não testadas: %d\\n\" % summary.untested_functions\n\treport += \"\\n\"\n\t\n\t# Classificação de cobertura\n\tvar grade = _get_coverage_grade(summary.overall_coverage_percentage)\n\treport += \"🎯 CLASSIFICAÇÃO: %s\\n\\n\" % grade\n\t\n\t# Arquivos com pior cobertura\n\tvar uncovered = get_uncovered_files()\n\tif uncovered.size() > 0:\n\t\treport += \"📉 ARQUIVOS COM MENOR COBERTURA:\\n\"\n\t\tfor i in range(min(5, uncovered.size())):\n\t\t\tvar file_data = uncovered[i]\n\t\t\treport += \"  %s: %.1f%% (%d funções não testadas)\\n\" % [file_data.file, file_data.coverage, file_data.untested_functions]\n\t\treport += \"\\n\"\n\t\n\t# Arquivos com melhor cobertura\n\tvar well_covered = get_best_covered_files()\n\tif well_covered.size() > 0:\n\t\treport += \"📈 ARQUIVOS COM MELHOR COBERTURA:\\n\"\n\t\tfor i in range(min(5, well_covered.size())):\n\t\t\tvar file_data = well_covered[i]\n\t\t\treport += \"  %s: %.1f%% (%d funções testadas)\\n\" % [file_data.file, file_data.coverage, file_data.tested_functions]\n\t\treport += \"\\n\"\n\t\n\t# Sugestões de melhoria\n\tvar suggestions = suggest_test_improvements()\n\tif suggestions.size() > 0:\n\t\treport += \"💡 SUGESTÕES DE MELHORIA:\\n\"\n\t\tvar high_priority = suggestions.filter(func(s): return s.priority == \"high\")\n\t\tvar medium_priority = suggestions.filter(func(s): return s.priority == \"medium\")\n\t\t\n\t\tif high_priority.size() > 0:\n\t\t\treport += \"  🔴 Alta prioridade:\\n\"\n\t\t\tfor suggestion in high_priority.slice(0, 3):\n\t\t\t\treport += \"    • %s\\n\" % suggestion.message\n\t\t\n\t\tif medium_priority.size() > 0:\n\t\t\treport += \"  🟡 Média prioridade:\\n\"\n\t\t\tfor suggestion in medium_priority.slice(0, 5):\n\t\t\t\treport += \"    • %s\\n\" % suggestion.message\n\t\treport += \"\\n\"\n\t\n\treport += \"=\" * 60 + \"\\n\"\n\treport += \"Relatório gerado em: %s\\n\" % Time.get_datetime_string_from_system()\n\t\n\treturn report\n\nfunc _get_coverage_grade(percentage: float) -> String:\n\t\"\"\"Retorna nota baseada na porcentagem de cobertura\"\"\"\n\tif percentage >= 90:\n\t\treturn \"A+ (Excelente)\"\n\telif percentage >= 80:\n\t\treturn \"A (Muito Bom)\"\n\telif percentage >= 70:\n\t\treturn \"B (Bom)\"\n\telif percentage >= 60:\n\t\treturn \"C (Regular)\"\n\telif percentage >= 50:\n\t\treturn \"D (Insuficiente)\"\n\telse:\n\t\treturn \"F (Inadequado)\"\n\nfunc _get_test_files() -> Array:\n\t\"\"\"Obtém lista de arquivos de teste\"\"\"\n\tvar files = []\n\tvar dir = DirAccess.open(test_path)\n\t\n\tif dir:\n\t\t_scan_directory_recursive(dir, test_path, files, \"test_\")\n\t\n\treturn files\n\nfunc _get_source_files() -> Array:\n\t\"\"\"Obtém lista de arquivos de código fonte\"\"\"\n\tvar files = []\n\tvar dir = DirAccess.open(project_path)\n\t\n\tif dir:\n\t\t_scan_directory_recursive(dir, project_path, files)\n\t\n\treturn files\n\nfunc _scan_directory_recursive(dir: DirAccess, path: String, files: Array, prefix: String = \"\"):\n\t\"\"\"Escaneia diretório recursivamente\"\"\"\n\tdir.list_dir_begin()\n\tvar file_name = dir.get_next()\n\t\n\twhile file_name != \"\":\n\t\tvar full_path = path + \"/\" + file_name\n\t\t\n\t\tif dir.current_is_dir() and not file_name.begins_with(\".\"):\n\t\t\tvar sub_dir = DirAccess.open(full_path)\n\t\t\tif sub_dir:\n\t\t\t\t_scan_directory_recursive(sub_dir, full_path, files, prefix)\n\t\telif file_name.ends_with(\".gd\"):\n\t\t\tif prefix.is_empty() or file_name.begins_with(prefix):\n\t\t\t\tfiles.append(full_path)\n\t\t\n\t\tfile_name = dir.get_next()\n\nfunc _read_file_content(file_path: String) -> String:\n\t\"\"\"Lê conteúdo de um arquivo\"\"\"\n\tvar file = FileAccess.open(file_path, FileAccess.READ)\n\tif not file:\n\t\treturn \"\"\n\t\n\tvar content = file.get_as_text()\n\tfile.close()\n\treturn content\n\nfunc cleanup():\n\t\"\"\"Limpa recursos do reporter\"\"\"\n\tcoverage_data.clear()\n\ttest_files.clear()\n\tsource_files.clear()\n\tinstance = null\n"