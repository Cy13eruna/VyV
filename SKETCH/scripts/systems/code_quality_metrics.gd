## Code Quality Metrics - Analisador de Qualidade de C√≥digo\n## Analisa m√©tricas de qualidade, complexidade e manutenibilidade\n\nclass_name CodeQualityMetrics\nextends RefCounted\n\n# Singleton pattern\nstatic var instance: CodeQualityMetrics\n\n# M√©tricas coletadas\nvar quality_metrics: Dictionary = {}\nvar file_metrics: Dictionary = {}\nvar overall_score: float = 0.0\n\n# Configura√ß√µes de an√°lise\nvar max_function_length: int = 50\nvar max_class_length: int = 500\nvar max_cyclomatic_complexity: int = 10\nvar min_comment_ratio: float = 0.1\nvar max_nesting_depth: int = 4\n\n# Padr√µes de an√°lise\nvar function_pattern = RegEx.new()\nvar class_pattern = RegEx.new()\nvar comment_pattern = RegEx.new()\nvar complexity_patterns: Array = []\n\nstatic func get_instance() -> CodeQualityMetrics:\n\tif not instance:\n\t\tinstance = CodeQualityMetrics.new()\n\treturn instance\n\nfunc _init():\n\tif not instance:\n\t\tinstance = self\n\tsetup_patterns()\n\nfunc setup_patterns():\n\t\"\"\"Configura padr√µes regex para an√°lise\"\"\"\n\t# Padr√£o para fun√ß√µes\n\tfunction_pattern.compile(r\"func\\s+(\\w+)\\s*\\(\")\n\t\n\t# Padr√£o para classes\n\tclass_pattern.compile(r\"class_name\\s+(\\w+)\")\n\t\n\t# Padr√£o para coment√°rios\n\tcomment_pattern.compile(r\"#.*$\")\n\t\n\t# Padr√µes de complexidade\n\tvar if_pattern = RegEx.new()\n\tif_pattern.compile(r\"\\bif\\b\")\n\tcomplexity_patterns.append(if_pattern)\n\t\n\tvar elif_pattern = RegEx.new()\n\telif_pattern.compile(r\"\\belif\\b\")\n\tcomplexity_patterns.append(elif_pattern)\n\t\n\tvar for_pattern = RegEx.new()\n\tfor_pattern.compile(r\"\\bfor\\b\")\n\tcomplexity_patterns.append(for_pattern)\n\t\n\tvar while_pattern = RegEx.new()\n\twhile_pattern.compile(r\"\\bwhile\\b\")\n\tcomplexity_patterns.append(while_pattern)\n\nfunc analyze_project(project_path: String = \"SKETCH/scripts\") -> Dictionary:\n\t\"\"\"Analisa qualidade de todo o projeto\"\"\"\n\tprint(\"üîç Iniciando an√°lise de qualidade do c√≥digo...\")\n\t\n\tquality_metrics.clear()\n\tfile_metrics.clear()\n\t\n\t# Analisar todos os arquivos .gd\n\tvar files_to_analyze = _get_gdscript_files(project_path)\n\t\n\tfor file_path in files_to_analyze:\n\t\tanalyze_file(file_path)\n\t\n\t# Calcular m√©tricas gerais\n\tcalculate_overall_metrics()\n\t\n\tprint(\"‚úÖ An√°lise de qualidade conclu√≠da: %d arquivos analisados\" % files_to_analyze.size())\n\treturn quality_metrics\n\nfunc analyze_file(file_path: String) -> Dictionary:\n\t\"\"\"Analisa um arquivo espec√≠fico\"\"\"\n\tvar file = FileAccess.open(file_path, FileAccess.READ)\n\tif not file:\n\t\tprint(\"‚ö†Ô∏è N√£o foi poss√≠vel abrir arquivo: %s\" % file_path)\n\t\treturn {}\n\t\n\tvar content = file.get_as_text()\n\tfile.close()\n\t\n\tvar metrics = {\n\t\t\"file_path\": file_path,\n\t\t\"lines_of_code\": 0,\n\t\t\"lines_of_comments\": 0,\n\t\t\"blank_lines\": 0,\n\t\t\"functions\": [],\n\t\t\"classes\": [],\n\t\t\"cyclomatic_complexity\": 0,\n\t\t\"max_nesting_depth\": 0,\n\t\t\"comment_ratio\": 0.0,\n\t\t\"maintainability_score\": 0.0,\n\t\t\"issues\": []\n\t}\n\t\n\t# Analisar linha por linha\n\tvar lines = content.split(\"\\n\")\n\tvar current_function = null\n\tvar current_nesting = 0\n\tvar max_nesting = 0\n\t\n\tfor i in range(lines.size()):\n\t\tvar line = lines[i].strip_edges()\n\t\t\n\t\tif line.is_empty():\n\t\t\tmetrics.blank_lines += 1\n\t\telif line.begins_with(\"#\"):\n\t\t\tmetrics.lines_of_comments += 1\n\t\telse:\n\t\t\tmetrics.lines_of_code += 1\n\t\t\t\n\t\t\t# Detectar fun√ß√µes\n\t\t\tvar func_match = function_pattern.search(line)\n\t\t\tif func_match:\n\t\t\t\tif current_function:\n\t\t\t\t\tcurrent_function.end_line = i\n\t\t\t\t\tcurrent_function.length = current_function.end_line - current_function.start_line\n\t\t\t\t\n\t\t\t\tcurrent_function = {\n\t\t\t\t\t\"name\": func_match.get_string(1),\n\t\t\t\t\t\"start_line\": i + 1,\n\t\t\t\t\t\"end_line\": -1,\n\t\t\t\t\t\"length\": 0,\n\t\t\t\t\t\"complexity\": 1  # Complexidade base\n\t\t\t\t}\n\t\t\t\tmetrics.functions.append(current_function)\n\t\t\t\n\t\t\t# Detectar classes\n\t\t\tvar class_match = class_pattern.search(line)\n\t\t\tif class_match:\n\t\t\t\tmetrics.classes.append({\n\t\t\t\t\t\"name\": class_match.get_string(1),\n\t\t\t\t\t\"line\": i + 1\n\t\t\t\t})\n\t\t\t\n\t\t\t# Calcular complexidade ciclom√°tica\n\t\t\tfor pattern in complexity_patterns:\n\t\t\t\tvar matches = pattern.search_all(line)\n\t\t\t\tmetrics.cyclomatic_complexity += matches.size()\n\t\t\t\tif current_function:\n\t\t\t\t\tcurrent_function.complexity += matches.size()\n\t\t\t\n\t\t\t# Calcular profundidade de aninhamento\n\t\t\tvar indent_level = _calculate_indent_level(lines[i])\n\t\t\tmax_nesting = max(max_nesting, indent_level)\n\t\n\t# Finalizar fun√ß√£o atual\n\tif current_function:\n\t\tcurrent_function.end_line = lines.size()\n\t\tcurrent_function.length = current_function.end_line - current_function.start_line\n\t\n\t# Calcular m√©tricas derivadas\n\tvar total_lines = metrics.lines_of_code + metrics.lines_of_comments\n\tif total_lines > 0:\n\t\tmetrics.comment_ratio = float(metrics.lines_of_comments) / float(total_lines)\n\t\n\tmetrics.max_nesting_depth = max_nesting\n\t\n\t# Detectar problemas\n\tdetect_quality_issues(metrics)\n\t\n\t# Calcular score de manutenibilidade\n\tmetrics.maintainability_score = calculate_maintainability_score(metrics)\n\t\n\tfile_metrics[file_path] = metrics\n\treturn metrics\n\nfunc detect_quality_issues(metrics: Dictionary):\n\t\"\"\"Detecta problemas de qualidade no c√≥digo\"\"\"\n\tvar issues = []\n\t\n\t# Verificar fun√ß√µes muito longas\n\tfor func_data in metrics.functions:\n\t\tif func_data.length > max_function_length:\n\t\t\tissues.append({\n\t\t\t\t\"type\": \"long_function\",\n\t\t\t\t\"severity\": \"warning\",\n\t\t\t\t\"message\": \"Fun√ß√£o '%s' muito longa (%d linhas)\" % [func_data.name, func_data.length],\n\t\t\t\t\"line\": func_data.start_line\n\t\t\t})\n\t\t\n\t\tif func_data.complexity > max_cyclomatic_complexity:\n\t\t\tissues.append({\n\t\t\t\t\"type\": \"high_complexity\",\n\t\t\t\t\"severity\": \"warning\",\n\t\t\t\t\"message\": \"Fun√ß√£o '%s' muito complexa (complexidade: %d)\" % [func_data.name, func_data.complexity],\n\t\t\t\t\"line\": func_data.start_line\n\t\t\t})\n\t\n\t# Verificar arquivo muito longo\n\tif metrics.lines_of_code > max_class_length:\n\t\tissues.append({\n\t\t\t\"type\": \"long_file\",\n\t\t\t\"severity\": \"info\",\n\t\t\t\"message\": \"Arquivo muito longo (%d linhas de c√≥digo)\" % metrics.lines_of_code,\n\t\t\t\"line\": 1\n\t\t})\n\t\n\t# Verificar falta de coment√°rios\n\tif metrics.comment_ratio < min_comment_ratio:\n\t\tissues.append({\n\t\t\t\"type\": \"low_comments\",\n\t\t\t\"severity\": \"info\",\n\t\t\t\"message\": \"Poucos coment√°rios (%.1f%%)\" % (metrics.comment_ratio * 100),\n\t\t\t\"line\": 1\n\t\t})\n\t\n\t# Verificar aninhamento excessivo\n\tif metrics.max_nesting_depth > max_nesting_depth:\n\t\tissues.append({\n\t\t\t\"type\": \"deep_nesting\",\n\t\t\t\"severity\": \"warning\",\n\t\t\t\"message\": \"Aninhamento muito profundo (%d n√≠veis)\" % metrics.max_nesting_depth,\n\t\t\t\"line\": 1\n\t\t})\n\t\n\tmetrics.issues = issues\n\nfunc calculate_maintainability_score(metrics: Dictionary) -> float:\n\t\"\"\"Calcula score de manutenibilidade (0-100)\"\"\"\n\tvar score = 100.0\n\t\n\t# Penalizar por problemas\n\tfor issue in metrics.issues:\n\t\tmatch issue.severity:\n\t\t\t\"error\":\n\t\t\t\tscore -= 20.0\n\t\t\t\"warning\":\n\t\t\t\tscore -= 10.0\n\t\t\t\"info\":\n\t\t\t\tscore -= 5.0\n\t\n\t# Bonificar por boas pr√°ticas\n\tif metrics.comment_ratio >= min_comment_ratio * 2:\n\t\tscore += 5.0\n\t\n\tif metrics.cyclomatic_complexity <= max_cyclomatic_complexity / 2:\n\t\tscore += 5.0\n\t\n\treturn max(0.0, min(100.0, score))\n\nfunc calculate_overall_metrics():\n\t\"\"\"Calcula m√©tricas gerais do projeto\"\"\"\n\tvar total_files = file_metrics.size()\n\tvar total_loc = 0\n\tvar total_comments = 0\n\tvar total_functions = 0\n\tvar total_classes = 0\n\tvar total_complexity = 0\n\tvar total_issues = 0\n\tvar total_maintainability = 0.0\n\t\n\tvar issue_counts = {\"error\": 0, \"warning\": 0, \"info\": 0}\n\t\n\tfor file_path in file_metrics.keys():\n\t\tvar metrics = file_metrics[file_path]\n\t\t\n\t\ttotal_loc += metrics.lines_of_code\n\t\ttotal_comments += metrics.lines_of_comments\n\t\ttotal_functions += metrics.functions.size()\n\t\ttotal_classes += metrics.classes.size()\n\t\ttotal_complexity += metrics.cyclomatic_complexity\n\t\ttotal_issues += metrics.issues.size()\n\t\ttotal_maintainability += metrics.maintainability_score\n\t\t\n\t\tfor issue in metrics.issues:\n\t\t\tissue_counts[issue.severity] += 1\n\t\n\tquality_metrics = {\n\t\t\"total_files\": total_files,\n\t\t\"total_lines_of_code\": total_loc,\n\t\t\"total_lines_of_comments\": total_comments,\n\t\t\"total_functions\": total_functions,\n\t\t\"total_classes\": total_classes,\n\t\t\"average_file_size\": total_loc / max(1, total_files),\n\t\t\"average_functions_per_file\": float(total_functions) / max(1, total_files),\n\t\t\"total_cyclomatic_complexity\": total_complexity,\n\t\t\"average_complexity_per_function\": float(total_complexity) / max(1, total_functions),\n\t\t\"overall_comment_ratio\": float(total_comments) / max(1, total_loc + total_comments),\n\t\t\"total_issues\": total_issues,\n\t\t\"issue_breakdown\": issue_counts,\n\t\t\"average_maintainability_score\": total_maintainability / max(1, total_files),\n\t\t\"quality_grade\": _calculate_quality_grade(total_maintainability / max(1, total_files))\n\t}\n\t\n\toverall_score = quality_metrics.average_maintainability_score\n\nfunc _calculate_quality_grade(score: float) -> String:\n\t\"\"\"Calcula nota de qualidade baseada no score\"\"\"\n\tif score >= 90:\n\t\treturn \"A+\"\n\telif score >= 80:\n\t\treturn \"A\"\n\telif score >= 70:\n\t\treturn \"B\"\n\telif score >= 60:\n\t\treturn \"C\"\n\telif score >= 50:\n\t\treturn \"D\"\n\telse:\n\t\treturn \"F\"\n\nfunc _get_gdscript_files(directory: String) -> Array:\n\t\"\"\"Obt√©m lista de arquivos .gd recursivamente\"\"\"\n\tvar files = []\n\tvar dir = DirAccess.open(directory)\n\t\n\tif not dir:\n\t\tprint(\"‚ö†Ô∏è N√£o foi poss√≠vel abrir diret√≥rio: %s\" % directory)\n\t\treturn files\n\t\n\t_scan_directory_recursive(dir, directory, files)\n\treturn files\n\nfunc _scan_directory_recursive(dir: DirAccess, path: String, files: Array):\n\t\"\"\"Escaneia diret√≥rio recursivamente\"\"\"\n\tdir.list_dir_begin()\n\tvar file_name = dir.get_next()\n\t\n\twhile file_name != \"\":\n\t\tvar full_path = path + \"/\" + file_name\n\t\t\n\t\tif dir.current_is_dir() and not file_name.begins_with(\".\"):\n\t\t\tvar sub_dir = DirAccess.open(full_path)\n\t\t\tif sub_dir:\n\t\t\t\t_scan_directory_recursive(sub_dir, full_path, files)\n\t\telif file_name.ends_with(\".gd\"):\n\t\t\tfiles.append(full_path)\n\t\t\n\t\tfile_name = dir.get_next()\n\nfunc _calculate_indent_level(line: String) -> int:\n\t\"\"\"Calcula n√≠vel de indenta√ß√£o\"\"\"\n\tvar indent = 0\n\tfor char in line:\n\t\tif char == \"\\t\":\n\t\t\tindent += 1\n\t\telif char == \" \":\n\t\t\tindent += 0.25  # 4 espa√ßos = 1 tab\n\t\telse:\n\t\t\tbreak\n\treturn int(indent)\n\nfunc get_worst_files(count: int = 5) -> Array:\n\t\"\"\"Retorna arquivos com pior qualidade\"\"\"\n\tvar files_with_scores = []\n\t\n\tfor file_path in file_metrics.keys():\n\t\tvar metrics = file_metrics[file_path]\n\t\tfiles_with_scores.append({\n\t\t\t\"file\": file_path,\n\t\t\t\"score\": metrics.maintainability_score,\n\t\t\t\"issues\": metrics.issues.size()\n\t\t})\n\t\n\tfiles_with_scores.sort_custom(func(a, b): return a.score < b.score)\n\treturn files_with_scores.slice(0, count)\n\nfunc get_most_complex_functions(count: int = 10) -> Array:\n\t\"\"\"Retorna fun√ß√µes mais complexas\"\"\"\n\tvar complex_functions = []\n\t\n\tfor file_path in file_metrics.keys():\n\t\tvar metrics = file_metrics[file_path]\n\t\tfor func_data in metrics.functions:\n\t\t\tcomplex_functions.append({\n\t\t\t\t\"file\": file_path,\n\t\t\t\t\"function\": func_data.name,\n\t\t\t\t\"complexity\": func_data.complexity,\n\t\t\t\t\"length\": func_data.length,\n\t\t\t\t\"line\": func_data.start_line\n\t\t\t})\n\t\n\tcomplex_functions.sort_custom(func(a, b): return a.complexity > b.complexity)\n\treturn complex_functions.slice(0, count)\n\nfunc generate_quality_report() -> String:\n\t\"\"\"Gera relat√≥rio completo de qualidade\"\"\"\n\tvar report = \"üìä RELAT√ìRIO DE QUALIDADE DE C√ìDIGO\\n\"\n\treport += \"=\" * 60 + \"\\n\\n\"\n\t\n\t# M√©tricas gerais\n\treport += \"üìà M√âTRICAS GERAIS:\\n\"\n\treport += \"Arquivos analisados: %d\\n\" % quality_metrics.total_files\n\treport += \"Linhas de c√≥digo: %d\\n\" % quality_metrics.total_lines_of_code\n\treport += \"Linhas de coment√°rios: %d\\n\" % quality_metrics.total_lines_of_comments\n\treport += \"Fun√ß√µes: %d\\n\" % quality_metrics.total_functions\n\treport += \"Classes: %d\\n\" % quality_metrics.total_classes\n\treport += \"\\n\"\n\t\n\t# Qualidade\n\treport += \"üéØ QUALIDADE GERAL:\\n\"\n\treport += \"Score m√©dio: %.1f/100\\n\" % quality_metrics.average_maintainability_score\n\treport += \"Nota: %s\\n\" % quality_metrics.quality_grade\n\treport += \"Ratio de coment√°rios: %.1f%%\\n\" % (quality_metrics.overall_comment_ratio * 100)\n\treport += \"Complexidade m√©dia: %.1f\\n\" % quality_metrics.average_complexity_per_function\n\treport += \"\\n\"\n\t\n\t# Problemas\n\treport += \"‚ö†Ô∏è PROBLEMAS DETECTADOS:\\n\"\n\treport += \"Total: %d\\n\" % quality_metrics.total_issues\n\treport += \"Erros: %d\\n\" % quality_metrics.issue_breakdown.error\n\treport += \"Avisos: %d\\n\" % quality_metrics.issue_breakdown.warning\n\treport += \"Informa√ß√µes: %d\\n\" % quality_metrics.issue_breakdown.info\n\treport += \"\\n\"\n\t\n\t# Piores arquivos\n\tvar worst_files = get_worst_files(3)\n\tif worst_files.size() > 0:\n\t\treport += \"üìâ ARQUIVOS COM MENOR QUALIDADE:\\n\"\n\t\tfor file_data in worst_files:\n\t\t\treport += \"  %s: %.1f pontos (%d problemas)\\n\" % [file_data.file, file_data.score, file_data.issues]\n\t\treport += \"\\n\"\n\t\n\t# Fun√ß√µes mais complexas\n\tvar complex_functions = get_most_complex_functions(3)\n\tif complex_functions.size() > 0:\n\t\treport += \"üî• FUN√á√ïES MAIS COMPLEXAS:\\n\"\n\t\tfor func_data in complex_functions:\n\t\t\treport += \"  %s::%s: complexidade %d (%d linhas)\\n\" % [func_data.file, func_data.function, func_data.complexity, func_data.length]\n\t\treport += \"\\n\"\n\t\n\treport += \"=\" * 60 + \"\\n\"\n\treport += \"Relat√≥rio gerado em: %s\\n\" % Time.get_datetime_string_from_system()\n\t\n\treturn report\n\nfunc cleanup():\n\t\"\"\"Limpa recursos do analisador\"\"\"\n\tquality_metrics.clear()\n\tfile_metrics.clear()\n\tinstance = null\n"