## Test Stress Performance - Testes de Stress e Performance Extrema\n## Valida comportamento do sistema sob condi√ß√µes de carga pesada\n\nextends \"res://tests/test_framework.gd\"\n\nconst GameManagerClass = preload(\"res://scripts/game/game_manager.gd\")\nconst PerformanceProfiler = preload(\"res://scripts/systems/performance_profiler.gd\")\nconst MemoryLeakDetector = preload(\"res://scripts/systems/memory_leak_detector.gd\")\nconst BenchmarkSuite = preload(\"res://scripts/systems/benchmark_suite.gd\")\n\n# Configura√ß√µes de stress\nvar stress_units_count: int = 1000\nvar stress_domains_count: int = 100\nvar stress_turns_count: int = 50\nvar stress_players_count: int = 8\nvar stress_operations_per_turn: int = 100\n\n# Componentes de teste\nvar game_manager: GameManagerClass\nvar profiler: PerformanceProfiler\nvar memory_detector: MemoryLeakDetector\nvar benchmark_suite: BenchmarkSuite\n\n# M√©tricas de stress\nvar stress_metrics: Dictionary = {}\nvar performance_degradation: Dictionary = {}\nvar memory_usage_peak: int = 0\nvar operations_completed: int = 0\nvar operations_failed: int = 0\n\n# Mock classes otimizadas para stress\nclass StressHexGrid:\n\tvar dot_positions: Array = []\n\tvar cache: StressCache\n\t\n\tfunc _init():\n\t\tcache = StressCache.new()\n\t\t# Criar um mapa grande 20x20 para stress test\n\t\tfor y in range(20):\n\t\t\tfor x in range(20):\n\t\t\t\tdot_positions.append(Vector2(x * 30, y * 30))\n\t\n\tfunc get_dot_positions():\n\t\treturn dot_positions\n\t\n\tfunc has_method(method_name):\n\t\treturn method_name == \"cache\"\n\nclass StressCache:\n\tvar diamond_colors: Array = []\n\tvar connections: Array = []\n\t\n\tfunc _init():\n\t\t# Gerar cores e conex√µes para mapa 20x20 (400 posi√ß√µes)\n\t\tvar terrain_colors = [\n\t\t\tColor(0.0, 1.0, 0.0, 1.0),  # Verde - livre (70%)\n\t\t\tColor(0.0, 1.0, 1.0, 1.0),  # Azul - √°gua (15%)\n\t\t\tColor(0.4, 0.4, 0.4, 1.0),  # Cinza - montanha (10%)\n\t\t\tColor(0.2, 0.8, 0.2, 1.0)   # Verde claro - floresta (5%)\n\t\t]\n\t\t\n\t\t# Criar muitas conex√µes para stress test\n\t\tfor i in range(2000):  # Muitas conex√µes\n\t\t\tvar color_index = _get_weighted_terrain_index()\n\t\t\tdiamond_colors.append(terrain_colors[color_index])\n\t\t\t\n\t\t\t# Conex√µes adjacentes e diagonais\n\t\t\tif i < 400:  # 20x20 = 400 posi√ß√µes\n\t\t\t\tvar from_star = i\n\t\t\t\tvar to_star = (i + 1) % 400\n\t\t\t\tconnections.append({\"index_a\": from_star, \"index_b\": to_star})\n\t\t\t\t\n\t\t\t\t# Adicionar conex√µes diagonais para mais complexidade\n\t\t\t\tif i % 20 < 19:  # N√£o na borda direita\n\t\t\t\t\tvar diagonal = (i + 21) % 400\n\t\t\t\t\tconnections.append({\"index_a\": from_star, \"index_b\": diagonal})\n\t\n\tfunc _get_weighted_terrain_index() -> int:\n\t\t# 70% verde, 15% √°gua, 10% montanha, 5% floresta\n\t\tvar rand = randf()\n\t\tif rand < 0.70:\n\t\t\treturn 0  # Verde\n\t\telif rand < 0.85:\n\t\t\treturn 1  # √Ågua\n\t\telif rand < 0.95:\n\t\t\treturn 2  # Montanha\n\t\telse:\n\t\t\treturn 3  # Floresta\n\t\n\tfunc get_diamond_colors():\n\t\treturn diamond_colors\n\t\n\tfunc get_connections():\n\t\treturn connections\n\nclass StressStarMapper:\n\tvar stars_data: Dictionary = {}\n\t\n\tfunc _init():\n\t\t# Criar dados para mapa 20x20\n\t\tfor i in range(400):\n\t\t\tstars_data[i] = {\n\t\t\t\t\"id\": i,\n\t\t\t\t\"position\": Vector2(i % 20 * 30, i / 20 * 30),\n\t\t\t\t\"type\": \"normal\",\n\t\t\t\t\"resources\": randi() % 5,\n\t\t\t\t\"defense\": randi() % 3\n\t\t\t}\n\t\n\tfunc get_star_data(star_id: int):\n\t\treturn stars_data.get(star_id, null)\n\nclass StressParentNode:\n\tvar children_nodes: Array = []\n\t\n\tfunc add_child(node):\n\t\tchildren_nodes.append(node)\n\t\n\tfunc remove_child(node):\n\t\tchildren_nodes.erase(node)\n\t\n\tfunc get_children():\n\t\treturn children_nodes\n\nfunc setup_stress_test():\n\t\"\"\"Configura ambiente de stress test\"\"\"\n\tprint(\"üî• Configurando Stress Test - Mapa 20x20, %d unidades, %d jogadores\" % [stress_units_count, stress_players_count])\n\t\n\t# Inicializar sistemas de monitoramento\n\tprofiler = PerformanceProfiler.get_instance()\n\tprofiler.start_profiling()\n\t\n\tmemory_detector = MemoryLeakDetector.get_instance()\n\tmemory_detector.start_tracking()\n\t\n\tbenchmark_suite = BenchmarkSuite.get_instance()\n\t\n\t# Criar componentes de stress\n\tvar hex_grid = StressHexGrid.new()\n\tvar star_mapper = StressStarMapper.new()\n\tvar parent_node = StressParentNode.new()\n\t\n\t# Inicializar GameManager\n\tgame_manager = GameManagerClass.new()\n\tvar setup_result = game_manager.setup_references(hex_grid, star_mapper, parent_node)\n\tassert_true(setup_result.is_success(), \"GameManager deve ser configurado para stress test\")\n\t\n\t# Configurar sistema de turnos para m√∫ltiplos jogadores\n\tvar turn_manager = game_manager.shared_game_state.turn_manager\n\tturn_manager.setup(stress_players_count)\n\t\n\t# Resetar m√©tricas\n\tstress_metrics.clear()\n\tperformance_degradation.clear()\n\tmemory_usage_peak = 0\n\toperations_completed = 0\n\toperations_failed = 0\n\nfunc test_massive_unit_creation():\n\t\"\"\"Testa cria√ß√£o massiva de unidades\"\"\"\n\tsetup_stress_test()\n\t\n\tprofiler.start_timer(\"massive_unit_creation\")\n\t\n\tprint(\"üè≠ Criando %d unidades...\" % stress_units_count)\n\t\n\tvar created_units = []\n\tvar creation_failures = 0\n\tvar positions_used = []\n\t\n\t# Criar unidades em lotes para evitar sobrecarga\n\tvar batch_size = 50\n\tvar batches = stress_units_count / batch_size\n\t\n\tfor batch in range(batches):\n\t\tvar batch_start_time = Time.get_ticks_msec()\n\t\t\n\t\tfor i in range(batch_size):\n\t\t\tvar position = _find_free_position_stress(positions_used)\n\t\t\tif position >= 0:\n\t\t\t\tvar unit_result = game_manager.create_unit(position)\n\t\t\t\tif unit_result.is_success():\n\t\t\t\t\tcreated_units.append(unit_result.get_value())\n\t\t\t\t\tpositions_used.append(position)\n\t\t\t\t\toperations_completed += 1\n\t\t\t\telse:\n\t\t\t\t\tcreation_failures += 1\n\t\t\t\t\toperations_failed += 1\n\t\t\telse:\n\t\t\t\tcreation_failures += 1\n\t\t\t\toperations_failed += 1\n\t\t\n\t\t# Monitorar performance por lote\n\t\tvar batch_time = Time.get_ticks_msec() - batch_start_time\n\t\tvar memory_stats = profiler.get_memory_stats()\n\t\t\n\t\tif memory_stats.current > memory_usage_peak:\n\t\t\tmemory_usage_peak = memory_stats.current\n\t\t\n\t\t# Verificar degrada√ß√£o de performance\n\t\tif batch_time > 1000:  # Mais de 1 segundo por lote\n\t\t\tprint(\"‚ö†Ô∏è Degrada√ß√£o de performance detectada no lote %d: %d ms\" % [batch, batch_time])\n\t\n\tvar creation_time = profiler.end_timer(\"massive_unit_creation\")\n\t\n\t# Verificar resultados\n\tvar total_units = game_manager.get_all_units().size()\n\tassert_true(total_units > 0, \"Deve ter criado algumas unidades\")\n\tassert_true(creation_failures < stress_units_count * 0.1, \"Falhas devem ser < 10%: %d falhas\" % creation_failures)\n\t\n\tstress_metrics[\"unit_creation\"] = {\n\t\t\"total_time_ms\": creation_time,\n\t\t\"units_created\": total_units,\n\t\t\"creation_failures\": creation_failures,\n\t\t\"units_per_second\": total_units / (creation_time / 1000.0),\n\t\t\"peak_memory_mb\": memory_usage_peak / (1024 * 1024)\n\t}\n\t\n\tprint(\"‚úÖ Cria√ß√£o massiva: %d unidades em %.2f segundos (%.1f/sec)\" % \n\t\t[total_units, creation_time / 1000.0, stress_metrics.unit_creation.units_per_second])\n\nfunc test_intensive_movement_simulation():\n\t\"\"\"Testa simula√ß√£o intensiva de movimento\"\"\"\n\tsetup_stress_test()\n\t\n\t# Criar algumas unidades primeiro\n\tfor i in range(100):\n\t\tvar position = i * 4  # Espalhar unidades\n\t\tif position < 400:\n\t\t\tgame_manager.create_unit(position)\n\t\n\tprofiler.start_timer(\"intensive_movement\")\n\t\n\tprint(\"üèÉ Simulando %d turnos com movimento intensivo...\" % stress_turns_count)\n\t\n\tvar turn_manager = game_manager.shared_game_state.turn_manager\n\tvar successful_moves = 0\n\tvar blocked_moves = 0\n\tvar invalid_moves = 0\n\t\n\tfor turn in range(stress_turns_count):\n\t\tvar turn_start_time = Time.get_ticks_msec()\n\t\t\n\t\tfor player in range(stress_players_count):\n\t\t\tvar current_player = turn_manager.get_current_player()\n\t\t\t\n\t\t\t# Obter unidades do jogador\n\t\t\tvar all_units = game_manager.get_all_units()\n\t\t\tvar player_units = _get_player_units_stress(all_units, current_player)\n\t\t\t\n\t\t\t# Tentar mover m√∫ltiplas unidades por turno\n\t\t\tfor unit in player_units:\n\t\t\t\tvar valid_moves = game_manager.get_valid_adjacent_stars(unit)\n\t\t\t\t\n\t\t\t\tif valid_moves.size() > 0:\n\t\t\t\t\t# Tentar mover para posi√ß√£o aleat√≥ria\n\t\t\t\t\tvar target = valid_moves[randi() % valid_moves.size()]\n\t\t\t\t\tvar move_success = game_manager.move_unit_to_star(unit, target)\n\t\t\t\t\t\n\t\t\t\t\tif move_success:\n\t\t\t\t\t\tsuccessful_moves += 1\n\t\t\t\t\t\toperations_completed += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\tblocked_moves += 1\n\t\t\t\t\t\toperations_failed += 1\n\t\t\t\telse:\n\t\t\t\t\tinvalid_moves += 1\n\t\t\t\t\toperations_failed += 1\n\t\t\t\n\t\t\tturn_manager.next_turn()\n\t\t\n\t\t# Monitorar performance por turno\n\t\tvar turn_time = Time.get_ticks_msec() - turn_start_time\n\t\tif turn_time > 500:  # Mais de 500ms por turno\n\t\t\tprint(\"‚ö†Ô∏è Turno lento detectado %d: %d ms\" % [turn, turn_time])\n\t\n\tvar movement_time = profiler.end_timer(\"intensive_movement\")\n\t\n\tstress_metrics[\"movement_simulation\"] = {\n\t\t\"total_time_ms\": movement_time,\n\t\t\"successful_moves\": successful_moves,\n\t\t\"blocked_moves\": blocked_moves,\n\t\t\"invalid_moves\": invalid_moves,\n\t\t\"moves_per_second\": successful_moves / (movement_time / 1000.0),\n\t\t\"success_rate\": float(successful_moves) / float(successful_moves + blocked_moves + invalid_moves) * 100.0\n\t}\n\t\n\tprint(\"‚úÖ Movimento intensivo: %d movimentos bem-sucedidos em %.2f segundos (%.1f%% sucesso)\" % \n\t\t[successful_moves, movement_time / 1000.0, stress_metrics.movement_simulation.success_rate])\n\nfunc test_memory_stress_and_cleanup():\n\t\"\"\"Testa stress de mem√≥ria e limpeza\"\"\"\n\tsetup_stress_test()\n\t\n\tprofiler.start_timer(\"memory_stress\")\n\t\n\tprint(\"üß† Testando stress de mem√≥ria com cria√ß√£o/destrui√ß√£o c√≠clica...\")\n\t\n\tvar cycles = 10\n\tvar objects_per_cycle = 200\n\tvar memory_snapshots = []\n\t\n\tfor cycle in range(cycles):\n\t\tvar cycle_start_memory = memory_detector.take_memory_snapshot()\n\t\tmemory_snapshots.append(cycle_start_memory)\n\t\t\n\t\t# Criar muitos objetos\n\t\tvar created_objects = []\n\t\tfor i in range(objects_per_cycle):\n\t\t\tvar position = (cycle * objects_per_cycle + i) % 400\n\t\t\tvar unit_result = game_manager.create_unit(position)\n\t\t\tif unit_result.is_success():\n\t\t\t\tcreated_objects.append(unit_result.get_value())\n\t\t\t\tmemory_detector.track_object(unit_result.get_value(), \"stress_cycle_%d\" % cycle)\n\t\t\n\t\t# Criar alguns dom√≠nios tamb√©m\n\t\tfor i in range(10):\n\t\t\tvar domain_position = (cycle * 10 + i) % 400\n\t\t\tvar domain_result = game_manager.spawn_domain_with_unit(domain_position, (cycle % stress_players_count) + 1)\n\t\t\tif domain_result.is_success():\n\t\t\t\tmemory_detector.track_object(domain_result.get_value(), \"stress_domain_%d\" % cycle)\n\t\t\n\t\t# Verificar vazamentos\n\t\tvar potential_leaks = memory_detector.check_for_leaks()\n\t\tif potential_leaks.size() > 0:\n\t\t\tprint(\"‚ö†Ô∏è Poss√≠veis vazamentos detectados no ciclo %d: %d\" % [cycle, potential_leaks.size()])\n\t\t\n\t\t# Limpeza parcial\n\t\tif cycle % 3 == 0:  # Limpar a cada 3 ciclos\n\t\t\tgame_manager.clear_all_units()\n\t\t\tgame_manager.clear_all_domains()\n\t\t\tprint(\"üßπ Limpeza executada no ciclo %d\" % cycle)\n\t\n\tvar memory_time = profiler.end_timer(\"memory_stress\")\n\t\n\t# An√°lise final de mem√≥ria\n\tvar final_snapshot = memory_detector.take_memory_snapshot()\n\tvar initial_snapshot = memory_snapshots[0] if memory_snapshots.size() > 0 else {}\n\t\n\tvar memory_growth = 0\n\tif initial_snapshot.has(\"total_objects\") and final_snapshot.has(\"total_objects\"):\n\t\tmemory_growth = final_snapshot.total_objects - initial_snapshot.total_objects\n\t\n\tstress_metrics[\"memory_stress\"] = {\n\t\t\"total_time_ms\": memory_time,\n\t\t\"cycles_completed\": cycles,\n\t\t\"objects_per_cycle\": objects_per_cycle,\n\t\t\"memory_growth\": memory_growth,\n\t\t\"final_objects\": final_snapshot.get(\"total_objects\", 0),\n\t\t\"potential_leaks\": memory_detector.check_for_leaks().size()\n\t}\n\t\n\tprint(\"‚úÖ Stress de mem√≥ria: %d ciclos em %.2f segundos, crescimento: %d objetos\" % \n\t\t[cycles, memory_time / 1000.0, memory_growth])\n\nfunc test_concurrent_operations_simulation():\n\t\"\"\"Simula opera√ß√µes concorrentes\"\"\"\n\tsetup_stress_test()\n\t\n\tprofiler.start_timer(\"concurrent_operations\")\n\t\n\tprint(\"‚ö° Simulando opera√ß√µes concorrentes intensivas...\")\n\t\n\t# Criar base de unidades e dom√≠nios\n\tfor i in range(50):\n\t\tgame_manager.create_unit(i * 8)\n\t\tif i % 5 == 0:\n\t\t\tgame_manager.spawn_domain_with_unit(i * 8 + 1, (i % stress_players_count) + 1)\n\t\n\tvar operations_per_batch = 50\n\tvar batches = 20\n\tvar total_operations = 0\n\tvar operation_failures = 0\n\t\n\tfor batch in range(batches):\n\t\tvar batch_start = Time.get_ticks_msec()\n\t\t\n\t\t# Simular opera√ß√µes \"concorrentes\" (sequenciais r√°pidas)\n\t\tfor op in range(operations_per_batch):\n\t\t\tvar operation_type = randi() % 4\n\t\t\t\n\t\t\tmatch operation_type:\n\t\t\t\t0:  # Criar unidade\n\t\t\t\t\tvar pos = randi() % 400\n\t\t\t\t\tvar result = game_manager.create_unit(pos)\n\t\t\t\t\tif result.is_success():\n\t\t\t\t\t\ttotal_operations += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\toperation_failures += 1\n\t\t\t\t\n\t\t\t\t1:  # Mover unidade\n\t\t\t\t\tvar units = game_manager.get_all_units()\n\t\t\t\t\tif units.size() > 0:\n\t\t\t\t\t\tvar unit = units[randi() % units.size()]\n\t\t\t\t\t\tvar valid_moves = game_manager.get_valid_adjacent_stars(unit)\n\t\t\t\t\t\tif valid_moves.size() > 0:\n\t\t\t\t\t\t\tvar target = valid_moves[randi() % valid_moves.size()]\n\t\t\t\t\t\t\tif game_manager.move_unit_to_star(unit, target):\n\t\t\t\t\t\t\t\ttotal_operations += 1\n\t\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\toperation_failures += 1\n\t\t\t\t\n\t\t\t\t2:  # Criar dom√≠nio\n\t\t\t\t\tvar pos = randi() % 400\n\t\t\t\t\tvar player = (randi() % stress_players_count) + 1\n\t\t\t\t\tvar result = game_manager.spawn_domain_with_unit(pos, player)\n\t\t\t\t\tif result.is_success():\n\t\t\t\t\t\ttotal_operations += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\toperation_failures += 1\n\t\t\t\t\n\t\t\t\t3:  # Consultar estado\n\t\t\t\t\tvar units = game_manager.get_all_units()\n\t\t\t\t\tvar domains = game_manager.get_all_domains()\n\t\t\t\t\ttotal_operations += 1\n\t\t\n\t\tvar batch_time = Time.get_ticks_msec() - batch_start\n\t\tif batch_time > 200:  # Mais de 200ms por lote\n\t\t\tprint(\"‚ö†Ô∏è Lote lento %d: %d ms\" % [batch, batch_time])\n\t\n\tvar concurrent_time = profiler.end_timer(\"concurrent_operations\")\n\t\n\tstress_metrics[\"concurrent_operations\"] = {\n\t\t\"total_time_ms\": concurrent_time,\n\t\t\"total_operations\": total_operations,\n\t\t\"operation_failures\": operation_failures,\n\t\t\"operations_per_second\": total_operations / (concurrent_time / 1000.0),\n\t\t\"success_rate\": float(total_operations) / float(total_operations + operation_failures) * 100.0\n\t}\n\t\n\tprint(\"‚úÖ Opera√ß√µes concorrentes: %d opera√ß√µes em %.2f segundos (%.1f ops/sec)\" % \n\t\t[total_operations, concurrent_time / 1000.0, stress_metrics.concurrent_operations.operations_per_second])\n\nfunc test_performance_degradation_analysis():\n\t\"\"\"Analisa degrada√ß√£o de performance ao longo do tempo\"\"\"\n\tsetup_stress_test()\n\t\n\tprint(\"üìâ Analisando degrada√ß√£o de performance...\")\n\t\n\tvar baseline_benchmark = benchmark_suite.run_all_benchmarks()\n\tbenchmark_suite.save_baseline(\"stress_baseline\")\n\t\n\t# Executar opera√ß√µes que podem causar degrada√ß√£o\n\ttest_massive_unit_creation()\n\ttest_intensive_movement_simulation()\n\ttest_memory_stress_and_cleanup()\n\t\n\t# Executar benchmarks novamente\n\tvar post_stress_benchmark = benchmark_suite.run_all_benchmarks()\n\tvar comparison = benchmark_suite.compare_with_baseline(\"stress_baseline\")\n\t\n\t# Analisar degrada√ß√£o\n\tvar degraded_operations = []\n\tfor benchmark_name in comparison.keys():\n\t\tvar bench_comparison = comparison[benchmark_name]\n\t\tfor metric in bench_comparison.keys():\n\t\t\tvar metric_data = bench_comparison[metric]\n\t\t\tif metric.ends_with(\"_per_sec\") and metric_data.percent_change < -10.0:  # Degrada√ß√£o > 10%\n\t\t\t\tdegraded_operations.append({\n\t\t\t\t\t\"operation\": \"%s::%s\" % [benchmark_name, metric],\n\t\t\t\t\t\"degradation_percent\": metric_data.percent_change,\n\t\t\t\t\t\"baseline\": metric_data.baseline,\n\t\t\t\t\t\"current\": metric_data.current\n\t\t\t\t})\n\t\n\tperformance_degradation = {\n\t\t\"degraded_operations\": degraded_operations,\n\t\t\"total_degraded\": degraded_operations.size(),\n\t\t\"comparison_data\": comparison\n\t}\n\t\n\tif degraded_operations.size() > 0:\n\t\tprint(\"‚ö†Ô∏è Degrada√ß√£o detectada em %d opera√ß√µes:\" % degraded_operations.size())\n\t\tfor op in degraded_operations:\n\t\t\tprint(\"  %s: %.1f%% mais lento\" % [op.operation, abs(op.degradation_percent)])\n\telse:\n\t\tprint(\"‚úÖ Nenhuma degrada√ß√£o significativa detectada\")\n\nfunc _find_free_position_stress(used_positions: Array) -> int:\n\t\"\"\"Encontra posi√ß√£o livre para stress test\"\"\"\n\tvar max_attempts = 100\n\tfor attempt in range(max_attempts):\n\t\tvar position = randi() % 400  # 20x20 mapa\n\t\tif not position in used_positions:\n\t\t\treturn position\n\treturn -1  # N√£o encontrou posi√ß√£o livre\n\nfunc _get_player_units_stress(all_units: Array, player_id: int) -> Array:\n\t\"\"\"Obt√©m unidades de um jogador para stress test\"\"\"\n\t# Para stress test, distribuir unidades igualmente\n\tvar units_per_player = all_units.size() / stress_players_count\n\tvar start_index = (player_id - 1) * units_per_player\n\tvar end_index = min(start_index + units_per_player, all_units.size())\n\t\n\tvar player_units = []\n\tfor i in range(start_index, end_index):\n\t\tif i < all_units.size():\n\t\t\tplayer_units.append(all_units[i])\n\t\n\treturn player_units\n\nfunc generate_stress_report() -> String:\n\t\"\"\"Gera relat√≥rio completo de stress test\"\"\"\n\tvar report = \"üî• RELAT√ìRIO DE STRESS TEST\\n\"\n\treport += \"=\" * 60 + \"\\n\\n\"\n\t\n\treport += \"‚öôÔ∏è CONFIGURA√á√ÉO DO STRESS TEST:\\n\"\n\treport += \"Unidades de stress: %d\\n\" % stress_units_count\n\treport += \"Dom√≠nios de stress: %d\\n\" % stress_domains_count\n\treport += \"Turnos simulados: %d\\n\" % stress_turns_count\n\treport += \"Jogadores: %d\\n\" % stress_players_count\n\treport += \"Opera√ß√µes por turno: %d\\n\" % stress_operations_per_turn\n\treport += \"\\n\"\n\t\n\t# Resultados por categoria\n\tfor test_name in stress_metrics.keys():\n\t\treport += \"üìä %s:\\n\" % test_name.to_upper().replace(\"_\", \" \")\n\t\tvar metrics = stress_metrics[test_name]\n\t\t\n\t\tfor metric in metrics.keys():\n\t\t\tvar value = metrics[metric]\n\t\t\tif metric.ends_with(\"_ms\"):\n\t\t\t\treport += \"  %s: %.2f ms\\n\" % [metric.replace(\"_ms\", \"\"), value]\n\t\t\telif metric.ends_with(\"_per_second\"):\n\t\t\t\treport += \"  %s: %.1f ops/sec\\n\" % [metric.replace(\"_per_second\", \"\"), value]\n\t\t\telif metric.ends_with(\"_rate\"):\n\t\t\t\treport += \"  %s: %.1f%%\\n\" % [metric.replace(\"_rate\", \"\"), value]\n\t\t\telse:\n\t\t\t\treport += \"  %s: %s\\n\" % [metric, str(value)]\n\t\t\n\t\treport += \"\\n\"\n\t\n\t# Degrada√ß√£o de performance\n\tif performance_degradation.size() > 0:\n\t\treport += \"üìâ DEGRADA√á√ÉO DE PERFORMANCE:\\n\"\n\t\tif performance_degradation.total_degraded > 0:\n\t\t\treport += \"Opera√ß√µes degradadas: %d\\n\" % performance_degradation.total_degraded\n\t\t\tfor op in performance_degradation.degraded_operations:\n\t\t\t\treport += \"  %s: %.1f%% mais lento\\n\" % [op.operation, abs(op.degradation_percent)]\n\t\telse:\n\t\t\treport += \"‚úÖ Nenhuma degrada√ß√£o significativa detectada\\n\"\n\t\treport += \"\\n\"\n\t\n\t# Resumo de opera√ß√µes\n\treport += \"üìà RESUMO GERAL:\\n\"\n\treport += \"Opera√ß√µes completadas: %d\\n\" % operations_completed\n\treport += \"Opera√ß√µes falhadas: %d\\n\" % operations_failed\n\tvar total_ops = operations_completed + operations_failed\n\tif total_ops > 0:\n\t\treport += \"Taxa de sucesso: %.1f%%\\n\" % (float(operations_completed) / float(total_ops) * 100.0)\n\treport += \"Pico de mem√≥ria: %.1f MB\\n\" % (memory_usage_peak / (1024.0 * 1024.0))\n\treport += \"\\n\"\n\t\n\treport += \"=\" * 60 + \"\\n\"\n\treport += \"Relat√≥rio gerado em: %s\\n\" % Time.get_datetime_string_from_system()\n\t\n\treturn report\n\nfunc cleanup_stress_test():\n\t\"\"\"Limpa recursos do stress test\"\"\"\n\tif game_manager:\n\t\tgame_manager.clear_all_units()\n\t\tgame_manager.clear_all_domains()\n\t\n\tif profiler:\n\t\tprofiler.stop_profiling()\n\t\n\tif memory_detector:\n\t\tmemory_detector.stop_tracking()\n\nfunc run_all_tests():\n\tprint(\"üî• Executando Testes de Stress e Performance Extrema...\")\n\t\n\ttest_massive_unit_creation()\n\ttest_intensive_movement_simulation()\n\ttest_memory_stress_and_cleanup()\n\ttest_concurrent_operations_simulation()\n\ttest_performance_degradation_analysis()\n\t\n\t# Gerar relat√≥rio final\n\tvar report = generate_stress_report()\n\tprint(\"\\n\" + report)\n\t\n\t# Cleanup\n\tcleanup_stress_test()\n\t\n\tprint(\"‚úÖ Testes de Stress conclu√≠dos - Sistema validado sob condi√ß√µes extremas!\")\n"