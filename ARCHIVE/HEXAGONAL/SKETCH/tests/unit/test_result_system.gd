## Test Result System - Testes Abrangentes do Sistema Result<T>\n## Cobertura: Cria√ß√£o, valida√ß√£o, encadeamento, error handling\n\nextends \"res://tests/test_framework.gd\"\n\nconst ResultClass = preload(\"res://scripts/core/result.gd\")\n\nfunc test_result_success_creation():\n\t# Teste de cria√ß√£o de Result de sucesso\n\tvar result = ResultClass.success(\"test_value\")\n\t\n\tassert_true(result.is_success(), \"Result deve ser de sucesso\")\n\tassert_false(result.is_error(), \"Result n√£o deve ser de erro\")\n\tassert_equal(result.get_value(), \"test_value\", \"Valor deve ser preservado\")\n\tassert_equal(result.get_error(), \"\", \"Erro deve estar vazio\")\n\nfunc test_result_error_creation():\n\t# Teste de cria√ß√£o de Result de erro\n\tvar result = ResultClass.error(\"test_error\", 404)\n\t\n\tassert_false(result.is_success(), \"Result n√£o deve ser de sucesso\")\n\tassert_true(result.is_error(), \"Result deve ser de erro\")\n\tassert_equal(result.get_error(), \"test_error\", \"Mensagem de erro deve ser preservada\")\n\tassert_equal(result.get_error_code(), 404, \"C√≥digo de erro deve ser preservado\")\n\nfunc test_result_success_with_null():\n\t# Teste de Result de sucesso com valor null\n\tvar result = ResultClass.success(null)\n\t\n\tassert_true(result.is_success(), \"Result deve ser de sucesso mesmo com null\")\n\tassert_equal(result.get_value(), null, \"Valor null deve ser preservado\")\n\nfunc test_result_success_with_complex_object():\n\t# Teste de Result com objeto complexo\n\tvar complex_data = {\n\t\t\"name\": \"test\",\n\t\t\"values\": [1, 2, 3],\n\t\t\"nested\": {\"key\": \"value\"}\n\t}\n\tvar result = ResultClass.success(complex_data)\n\t\n\tassert_true(result.is_success(), \"Result deve ser de sucesso\")\n\tassert_equal(result.get_value().name, \"test\", \"Propriedade do objeto deve ser preservada\")\n\tassert_equal(result.get_value().values.size(), 3, \"Array deve ser preservado\")\n\nfunc test_result_error_with_details():\n\t# Teste de Result de erro com detalhes\n\tvar details = {\"field\": \"username\", \"constraint\": \"required\"}\n\tvar result = ResultClass.error(\"Validation failed\", 400, details)\n\t\n\tassert_true(result.is_error(), \"Result deve ser de erro\")\n\tassert_equal(result.get_error(), \"Validation failed\", \"Mensagem deve ser preservada\")\n\tassert_equal(result.get_error_code(), 400, \"C√≥digo deve ser preservado\")\n\tassert_equal(result.get_details().field, \"username\", \"Detalhes devem ser preservados\")\n\nfunc test_result_chaining_success():\n\t# Teste de encadeamento de Results de sucesso\n\tvar result1 = ResultClass.success(10)\n\tvar result2 = ResultClass.success(20)\n\t\n\tif result1.is_success() and result2.is_success():\n\t\tvar combined = ResultClass.success(result1.get_value() + result2.get_value())\n\t\tassert_equal(combined.get_value(), 30, \"Encadeamento deve funcionar\")\n\nfunc test_result_chaining_with_error():\n\t# Teste de encadeamento com erro\n\tvar result1 = ResultClass.success(10)\n\tvar result2 = ResultClass.error(\"Failed\")\n\t\n\tvar final_result\n\tif result1.is_success() and result2.is_success():\n\t\tfinal_result = ResultClass.success(result1.get_value() + result2.get_value())\n\telse:\n\t\tfinal_result = result2 if result2.is_error() else result1\n\t\n\tassert_true(final_result.is_error(), \"Encadeamento deve propagar erro\")\n\tassert_equal(final_result.get_error(), \"Failed\", \"Mensagem de erro deve ser preservada\")\n\nfunc test_result_validation_patterns():\n\t# Teste de padr√µes de valida√ß√£o\n\tvar validate_positive = func(value):\n\t\tif value > 0:\n\t\t\treturn ResultClass.success(value)\n\t\telse:\n\t\t\treturn ResultClass.error(\"Value must be positive\")\n\t\n\tvar positive_result = validate_positive.call(5)\n\tvar negative_result = validate_positive.call(-3)\n\t\n\tassert_true(positive_result.is_success(), \"Valor positivo deve ser v√°lido\")\n\tassert_true(negative_result.is_error(), \"Valor negativo deve ser inv√°lido\")\n\nfunc test_result_combine_multiple():\n\t# Teste de combina√ß√£o de m√∫ltiplos Results\n\tvar results = [\n\t\tResultClass.success(\"A\"),\n\t\tResultClass.success(\"B\"),\n\t\tResultClass.success(\"C\")\n\t]\n\t\n\tvar combined_value = \"\"\n\tvar has_error = false\n\t\n\tfor result in results:\n\t\tif result.is_error():\n\t\t\thas_error = true\n\t\t\tbreak\n\t\telse:\n\t\t\tcombined_value += result.get_value()\n\t\n\tassert_false(has_error, \"N√£o deve haver erro\")\n\tassert_equal(combined_value, \"ABC\", \"Valores devem ser combinados\")\n\nfunc test_result_combine_with_error():\n\t# Teste de combina√ß√£o com erro\n\tvar results = [\n\t\tResultClass.success(\"A\"),\n\t\tResultClass.error(\"Failed at B\"),\n\t\tResultClass.success(\"C\")\n\t]\n\t\n\tvar error_result = null\n\tfor result in results:\n\t\tif result.is_error():\n\t\t\terror_result = result\n\t\t\tbreak\n\t\n\tassert_not_null(error_result, \"Deve encontrar erro\")\n\tassert_equal(error_result.get_error(), \"Failed at B\", \"Mensagem de erro deve ser correta\")\n\nfunc test_result_type_safety():\n\t# Teste de seguran√ßa de tipos\n\tvar string_result = ResultClass.success(\"hello\")\n\tvar int_result = ResultClass.success(42)\n\tvar bool_result = ResultClass.success(true)\n\t\n\tassert_true(string_result.get_value() is String, \"Tipo String deve ser preservado\")\n\tassert_true(int_result.get_value() is int, \"Tipo int deve ser preservado\")\n\tassert_true(bool_result.get_value() is bool, \"Tipo bool deve ser preservado\")\n\nfunc test_result_error_codes():\n\t# Teste de c√≥digos de erro espec√≠ficos\n\tvar not_found = ResultClass.error(\"Not found\", 404)\n\tvar unauthorized = ResultClass.error(\"Unauthorized\", 401)\n\tvar server_error = ResultClass.error(\"Server error\", 500)\n\t\n\tassert_equal(not_found.get_error_code(), 404, \"C√≥digo 404 deve ser preservado\")\n\tassert_equal(unauthorized.get_error_code(), 401, \"C√≥digo 401 deve ser preservado\")\n\tassert_equal(server_error.get_error_code(), 500, \"C√≥digo 500 deve ser preservado\")\n\nfunc test_result_immutability():\n\t# Teste de imutabilidade\n\tvar original_data = {\"count\": 5}\n\tvar result = ResultClass.success(original_data)\n\t\n\t# Modificar dados originais\n\toriginal_data.count = 10\n\t\n\t# Result deve manter refer√™ncia (comportamento esperado em GDScript)\n\tassert_equal(result.get_value().count, 10, \"Refer√™ncia deve ser mantida\")\n\nfunc test_result_performance():\n\t# Teste de performance b√°sica\n\tvar start_time = Time.get_ticks_msec()\n\t\n\t# Criar muitos Results\n\tfor i in range(1000):\n\t\tvar result = ResultClass.success(i)\n\t\tassert_true(result.is_success(), \"Result deve ser de sucesso\")\n\t\n\tvar end_time = Time.get_ticks_msec()\n\tvar duration = end_time - start_time\n\t\n\t# Deve ser r√°pido (menos de 100ms para 1000 opera√ß√µes)\n\tassert_true(duration < 100, \"Performance deve ser adequada: %d ms\" % duration)\n\nfunc run_all_tests():\n\tprint(\"üß™ Executando Testes do Sistema Result<T>...\")\n\t\n\ttest_result_success_creation()\n\ttest_result_error_creation()\n\ttest_result_success_with_null()\n\ttest_result_success_with_complex_object()\n\ttest_result_error_with_details()\n\ttest_result_chaining_success()\n\ttest_result_chaining_with_error()\n\ttest_result_validation_patterns()\n\ttest_result_combine_multiple()\n\ttest_result_combine_with_error()\n\ttest_result_type_safety()\n\ttest_result_error_codes()\n\ttest_result_immutability()\n\ttest_result_performance()\n\t\n\tprint(\"‚úÖ Todos os testes do Sistema Result<T> passaram!\")\n"